## 41.Debounce&Throttle
디바운스와 스로틀은 공부는 했지만, 이전 프로젝트에서 적용하지 못했던 부분이 있었다. 그 결과 UserTest에서 좋지 못한 평가를 받았다. 오늘은 해당 주제에 대해서 다뤄보자. 

### 1. 디바운스와 스로틀이 필요한 상황
<span style="color:orange">모던자바스크립트</span>에 따르면, 디바운스와 스로틀은 `Scroll`, `Resize`, `Input`, `Mousemove` 같은 이벤트와 관련있다. 이와 같은 이벤트들이 짧은 시간 간격으로 연속해서 발생을 일으키기 때문이다. 

연속적으로 발생되는 이벤트는 과도하게 호출되며 성능저하를 발생시킨다. <span style="color:orange">디바운스와 스로틀</span>은 짧은 시간 간격으로 연속해서 발생하는 이벤트를 그룹화해서 과도한 이벤트 헨들러의 호출을 방지하는 기법이다. 

<details>
<summary>첫째, 코드살펴보기(모던자바스크립트)</summary>

<div style="height: 400px; overflow-y: scroll;">

```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <button>Click Me</button>
  <br/><br/>
  <table style="text-align: justify; border:1px solid black">
    <tr style="color:lightcoral; border-bottom:1px soild black">
      <th width="150px" style="border-bottom:1px solid black">이벤트종류</th>
      <th width="100px" style="border-bottom:1px solid black">이벤트횟수</th>
    </tr>
    <tr>
      <td>일반 클릭</td>
      <td><span class="normal-msg">0</span></td>
    </tr>
    <tr>
      <td>디바운스 이벤트</td>
      <td><span class="debounce-msg">0</span></td>
    </tr>
    <tr>
      <td>스로틀 이벤트</td>
      <td><span class="throttle-msg">0</span></td>
    </tr>
  </table>  
  <script>
    const $button = document.querySelector('button')
    const $normalMsg = document.querySelector('.normal-msg')
    const $debounceMsg = document.querySelector('.debounce-msg')
    const $throttleMsg = document.querySelector('.throttle-msg')

    const debounce = (callback, delay) => {
      let tiemId;
      return (...args) => {
        if(tiemId) clearTimeout(tiemId);
        tiemId = setTimeout(callback, delay, ...args)
      }
    }

    const throttle = (callback, delay) => {
      let tiemId;
      return (...args) => {
        if(tiemId) return;
        tiemId = setTimeout(()=>{
          callback(...args);
          tiemId = null
        },delay)
      }
    }

    $button.addEventListener('click', () => {
      $normalMsg.textContent = +$normalMsg.textContent + 1;
    })

    $button.addEventListener('click', debounce(() => {
      $debounceMsg.textContent = +$debounceMsg.textContent +1;
    }, 1000));

    $button.addEventListener('click', throttle(() => {
      $throttleMsg.textContent = +$throttleMsg.textContent +1;
    }, 1000));

  </script>
</body>
</html>
```

</div>
</details>
<div align="center"><img src="../img/debounce%26throttle1.gif" width="100%"></div>

### 2. 디바운스
디바운스는 광클하는 사람들의 클릭 이벤트를 제어한다. 아무리 연속적인 광클을 해도 동작은 마지막 클릭이 종료된 다음 delay를 설정한 1초 뒤에 실행된다. 

조금 있어보이게 설명하면, 연속해서 이벤트가 발생된 시점에서 마지막 이벤트가 종료된 후 일정시간이 경과한 후에 한해서 동작이 이뤄지게 하는 것이 디바운스의 핵심이다. 

예를 들어, resize 이벤트 처리나, input 요소에 입력된 값으로 ajax 요청하는 입력 필드 자동완성 UI 구현, 버튼 중복 클릭 방지 처리 등에 유용하게 사용된다. 실무에서는 Lodash의 debounce 함수를 사용하는 것이 권장된다. 

```html
<!--DOCUMENT - HTML -->
<body>
  <input type="text">
  <div class="msg"></div>
  <script>
    const $input = document.querySelector('input');
    const $msg = document.querySelector('.msg')

    const debounce = (callback, delay) => {
      let tiemId;
      return (...args) => {
        if(tiemId) clearTimeout(tiemId)
        tiemId = setTimeout(callback, delay, ...args)
      };
    };

    $input.oninput = debounce(e => {
      $msg.textContent = e.target.value;
    }, 1000)
  </script>
  
</body>
```

1. input 이벤트가 발생될 때마다. 선언된 `debounce(callback, delay)`가 동작한다.
2. debounce 함수는 인수를 받아서 동작하는데, 먼저 tiemId의 여부를 관찰한다. 
3. tiemId 기존애 등록되어 있다면, clearTimeout()를 통해서 등록된 setTimeout() 제거한다. 
4. 추가로 입력되지 않는다면, `setTimeout(callback, delay, ...args)`이 실행되며, callback 함수의 로직이 동작하는 원리로 동작한다.

### 3. 리액트(tsx)와 디바운스

```tsx 
const Debounce: React.FC = () => {
  const [inputValue, setInputValue] = useState<string>("");
  const [printInput, setPrintInput] = useState<string>("");
  const [printInput2, setPrintInput2] = useState<string>("");

  const handleInputChange = (e: ChangeEvent<HTMLInputElement>) => {
    setInputValue(e.target.value);
    DebounceUseCallback(e.target.value)
    Debounce(e.target.value)
  };

  // eslint-disable-next-line
  const DebounceUseCallback = useCallback(
    _.debounce((text: string) => {
      setPrintInput(text);
    }, 2000),
    []
  );
  const Debounce = 
    _.debounce((text: string) => {
      setPrintInput2(text);
    }, 2000)

  const debounceFn = (callback:() => void, delay: number) => {
    let timer: NodeJS.Timeout | null = null;

    return () => {
      timer && clearTimeout(timer);
      timer = setTimeout(callback, delay);
    };
  };
  const handleButtonClick = debounceFn(() => {
    console.log("디바운스 테스트");
  }, 500);

  return (
    <div>
      <input type="text" value={inputValue} onChange={handleInputChange} />
      <div>Debounce(useCallback): {printInput}</div>
      <div>Debounce(useCallback No): {printInput2}</div>
      <button onClick={handleButtonClick}>디바운스 테스트</button>
    </div>
  );
};
```

<br/>
<div align="center"><img src="../img/debounce%26throttle2.gif" width="100%"></div>

우여곡절이 많았다. JSX도 아니고, TSX구문으로 컴포넌트를 만들다 보니 고려해야할 사항이 너무 많았다. 그럼에도 제어를 했고.. 성공을 했다. `handleButtonClick`은 버튼이벤트가 발생되었을 때 동작하는 디바운스이고, `DebounceUseCallback`는 input 이밴트가 발생했을 때 동작하는 디바운스이다.  

<details>
<summary>(1) handleButtonClick 버튼이벤트</summary>

버튼의 경우, 이전 프로젝트 유저피드백시에 받았던 부분이었다. 그때에는 사실 구현하지 못하였다. 좋아요/스크립트/입력버튼 등에서 이러한 제어없이 그냥 동작하였다. 완성도를 높이는 것 중에 이러한 내용들도 들어갈 것이다. 

- handleButtonClick 실행 : debounceFn(callback, delay)를 호출하며, 인자로 선언한 내용을 가져간다. 
  - 인자(1) : callback() : debounceFn를 통하여 실행될 내부함수이다. 테스트를 위해 콘솔에 디바운스의 결과가 출력되도록 기록하였다.
  - 인자(2) : delay : debounceFn에서 제어될 setTimeout 메서드의 시간이 기록된다. 
- debounceFn(callback, delay) 실행 
  - timer : setTimeout 메서드가 등록될 식별자로, 선언하고 null을 할당한다. 
  - 반환 (1) : timer && clearTimeout(timer); 기존에 있던 timer가 존재하면, setTimeout의 등록과 실행을 제거한다. 
  - 반환 (2) : timer = setTimeout(callback, delay); 그 후에, timer에 setTimeout을 등록한다. 
  - 추가적인 버튼 입력이 없다면, 등록된 setTimeout에 따라 코드가 동작된다. 

</details>

<details>
<summary>(2) Debounce : useCallback이 없을 때 </summary>

</details>

<details>
<summary>(3) DebounceUseCallback : useCallback이 있을 때 </summary>

</details>