## 37장 Set & Map, Hash fUnction 
### 37.1 Set 자료객체 

Set 객체는 중복되지 않는 유일한 값들의 집합으로, `배열 Array`과 유사하지만 차이가 있다. 

|Set|Array|구분|
|:--:|:--:|:--|
|X|O|중복되는 요소를 포함할 수 있다.|
|X|O|index에 의미가 있으며, index로 요소에 접근할 수 있다.|

#### 37.1.1 Set 객체의 생성
```javascript 
const newSet = new Set();
```

Set 객체는 New 키워드와 함께 생성자 함수로 생성되며, 이터러블로 전달된 인수(중복값 존재)는 생성자 함수에 의해서 중복값이 제거된 상태로 반환되는 객체를 생성한다. 이 과정에서 Set 자체는 요소에 대한 인덱스를 제공하지는 않기에, 특정 인덱스레 요소에 접근하는 것은 불가능하다. 그럼에도 Set은 내부적으로 원소의 순서를 유지하며, 삽입된 순서대로 요소가 저장된다는 측면에서 Object와 다르다. 정리하면 순서가 보장되지만, 인덱스를 통한 접근은 지원하지 않는다. 

  - [이터러블과 관련된 곳은 다른 것은 정리해 두었음](https://github.com/19Edwin92/JS-study/blob/main/modernjs/37.set&map.md)으로 해당 부분을 참고바란다. 


<details>
<summary>1. Set 을 활용하지 않고, 중복을 제거하는 방법</summary>

  ```javascript
  const uniq = array => array.filter((v, i, self) => self.indexOf(v) === i); 
  console.log(uniq([2,1,2,3,4,5,6]));
  // 위의 함수는 배열을 매개변수로 받아, filter 메서드를 실행한다. 
  // filter 메서드는 매개변수1(요소 하나씩), 매개변수2(요소의 인덱스), 매개변수3(배열전체)를 받는다. 
  // 배열 전체에서 처음 등장하는 value(값)과 그 index(위치)이 동일한 경우만 반환한다. 
  ```
</details>

<details>
<summary>2. Set 을 활용하여, 중복을 제거하는 방법 및 Set의 매서드들(size, add, has, delete)</summary>

  ```javascript
  const uniq = array => [...new Set(array)];
  console.log(uniq([2,1,2,3,4,5,6]))
  ```

  new 키워드와 함께 선언된 자료구조를 통해서 중복값을 빠르게 제거할 수 있다. 

  - Set의 메서드들

    ```javascript
    const set = new Set([1,2,3,4,5,6,7,8,9])
    ```

    |매서드|기능|사용예시|
    |:--:|:--:|:--|
    |set.size|요소 개수 확인| `console.log(set.size);` 위의 사례에서는 9가 반환된다.|
    |set.add|요수 추가 입력| `set.add(0).add(11)` 이와 같이 add는 연속적으로 붙여서 사용할 수 있다. 그러나 중복은 허용하지 않는다. <br/> Set 객체는 객체나 배열, 함수와 같은 자바스트립트의 모든 값을 요소로 저장할 수 있다. |
    |set.has|요소 존재 확인|`set.has(2) // true`  Set 객체의 특정 요소가 존재하는지 확인하기 위한 메서드이다. has는 특정 요소의 존재 여부를 진위값으로 반환한다. set 안에 값이 존재하면 true를 그렇지 않으면 false를 반환한다.|
    |set.delete|요소 삭제|`set.delete(2)` 주의할 점이 있다. Set은 특정 인덱스를 가지지 않기 때문에 삭제를 원할 경우, 요소의 값을 입력해야 한다. <br/> 이때, set 안에 존재하지 않는 요소를 제거하고자 할 때에는 undefined가 아니라 동작을 무시한다. <br/> 또한 `delete 메서드`는 add와 달리 연속적인 수행이 어렵다. 한 번에 하나씩만 선언이 가능하다. 이는 delete 메서드가 삭제 여부의 성공과 실패를 진위 값으로 반환하기 때문이다.  |
    |set.clear|요소 일괄 삭제|`set.clear` Set 객체 내의 모든 요소에 대한 일괄 삭제를 수행한다. 그 결과는 `undefined` 이다. |
    |set.forEach|요소순회(1)|그러나 기억할 것이 있다. Set 객체는 순서에 의미가 없어 배열과같이 인덱스를 갖지 않는다는 점이다. 다만 입력되로 이터러블이 될 뿐|
    |`for (const value of set) {}`|요소순회(2)|이터러블이라는 것은 `for... of`문이 가능하다는 이야기이다.|
    |[...set]|스프레드 문법의 대상|이터러블이기에 Set은 스프레드 문법의 대상이 될 수 있다.|
    |배열 구조분해할당(디스트럭처링)|구조분해할당|이터러블이기에 구조분해할당이 가능하다.|
  
</details>
<br/><br/>

### 37.1.8 Set 객체의 수학적 집합 접근 : 교집합, 합집합, 차집합, 부분집합과 상위집합

1. 교집합 : A ∩ B 

```javascript 
Set.prototype.intersection = function (set) {
  const result = new Set();
  for (const value of set) {
    if (this.has(value)) result.add(value)
  }
  return result;
}

const setA = new Set([1,2,3,4,])
const setB = new Set([2,4,])
console.log(setA.intersection(setB))
```

위에서 선언한 `intersection`은 일종의 `사용자 정의 프로토타입 메서드`라고 부를 수 있다. 프로토타입 메서드는 객체의 프로토타입에 직접 메서드를 추가하는 것을 말한다. `Set.prototype.intersection`은 `Set.prototype`를 통해서 `Set`에 상속한 메서드이로, 모든 Set 객체에서 사용할 수 있도록 확장시켰다. 이렇게 선언된  프로토타입 메서드는 프로토타입 체인에 의해서 객체 인스턴스에서 호출될 수 있다. 여기서 this가 호출되는 시점을 보면, intersection 안에서 this는 메서드로 호출되었기에, 전역객체가 아니라. Set 객체에 바인딩된다. 