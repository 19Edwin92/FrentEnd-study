## 37장 Set & Map, Hash fUnction 
### 37.1 Set 자료객체 

Set 객체는 중복되지 않는 유일한 값들의 집합으로, `배열 Array`과 유사하지만 차이가 있다. 

|Set|Array|구분|
|:--:|:--:|:--|
|X|O|중복되는 요소를 포함할 수 있다.|
|X|O|index에 의미가 있으며, index로 요소에 접근할 수 있다.|

#### 37.1.1 Set 객체의 생성
```javascript 
const newSet = new Set();
```

Set 객체는 New 키워드와 함께 생성자 함수로 생성되며, 이터러블로 전달된 인수(중복값 존재)는 생성자 함수에 의해서 중복값이 제거된 상태로 반환되는 객체를 생성한다. 이 과정에서 Set 자체는 요소에 대한 인덱스를 제공하지는 않기에, 특정 인덱스레 요소에 접근하는 것은 불가능하다. 그럼에도 Set은 내부적으로 원소의 순서를 유지하며, 삽입된 순서대로 요소가 저장된다는 측면에서 Object와 다르다. 정리하면 순서가 보장되지만, 인덱스를 통한 접근은 지원하지 않는다. 

  - [이터러블과 관련된 곳은 다른 것은 정리해 두었음](https://github.com/19Edwin92/JS-study/blob/main/modernjs/37.set&map.md)으로 해당 부분을 참고바란다. 


<details>
<summary>1. Set 을 활용하지 않고, 중복을 제거하는 방법</summary>

  ```javascript
  const uniq = array => array.filter((v, i, self) => self.indexOf(v) === i); 
  console.log(uniq([2,1,2,3,4,5,6]));
  // 위의 함수는 배열을 매개변수로 받아, filter 메서드를 실행한다. 
  // filter 메서드는 매개변수1(요소 하나씩), 매개변수2(요소의 인덱스), 매개변수3(배열전체)를 받는다. 
  // 배열 전체에서 처음 등장하는 value(값)과 그 index(위치)이 동일한 경우만 반환한다. 
  ```
</details>

<details>
<summary>2. Set 을 활용하여, 중복을 제거하는 방법 및 Set의 매서드들(size, add, has, delete)</summary>

  ```javascript
  const uniq = array => [...new Set(array)];
  console.log(uniq([2,1,2,3,4,5,6]))
  ```

  new 키워드와 함께 선언된 자료구조를 통해서 중복값을 빠르게 제거할 수 있다. 

  - Set의 메서드들

    ```javascript
    const set = new Set([1,2,3,4,5,6,7,8,9])
    ```

    |매서드|기능|사용예시|
    |:--:|:--:|:--|
    |set.size|요소 개수 확인| `console.log(set.size);` 위의 사례에서는 9가 반환된다.|
    |set.add|요수 추가 입력| `set.add(0).add(11)` 이와 같이 add는 연속적으로 붙여서 사용할 수 있다. 그러나 중복은 허용하지 않는다. <br/> Set 객체는 객체나 배열, 함수와 같은 자바스트립트의 모든 값을 요소로 저장할 수 있다. |
    |set.has|요소 존재 확인|`set.has(2) // true`  Set 객체의 특정 요소가 존재하는지 확인하기 위한 메서드이다. has는 특정 요소의 존재 여부를 진위값으로 반환한다. set 안에 값이 존재하면 true를 그렇지 않으면 false를 반환한다.|
    |set.delete|요소 삭제|`set.delete(2)` 주의할 점이 있다. Set은 특정 인덱스를 가지지 않기 때문에 삭제를 원할 경우, 요소의 값을 입력해야 한다. <br/> 이때, set 안에 존재하지 않는 요소를 제거하고자 할 때에는 undefined가 아니라 동작을 무시한다. <br/> 또한 `delete 메서드`는 add와 달리 연속적인 수행이 어렵다. 한 번에 하나씩만 선언이 가능하다. 이는 delete 메서드가 삭제 여부의 성공과 실패를 진위 값으로 반환하기 때문이다.  |
    |set.clear|요소 일괄 삭제|`set.clear` Set 객체 내의 모든 요소에 대한 일괄 삭제를 수행한다. 그 결과는 `undefined` 이다. |
    |set.forEach|요소순회(1)|그러나 기억할 것이 있다. Set 객체는 순서에 의미가 없어 배열과같이 인덱스를 갖지 않는다는 점이다. 다만 입력되로 이터러블이 될 뿐|
    |`for (const value of set) {}`|요소순회(2)|이터러블이라는 것은 `for... of`문이 가능하다는 이야기이다.|
    |[...set]|스프레드 문법의 대상|이터러블이기에 Set은 스프레드 문법의 대상이 될 수 있다.|
    |배열 구조분해할당(디스트럭처링)|구조분해할당|이터러블이기에 구조분해할당이 가능하다.|
  
</details>
<br/><br/>

#### 37.1.8 Set 객체의 수학적 집합 접근 : 교집합, 합집합, 차집합, 부분집합과 상위집합

<details>
<summary>1. 교집합 : A ∩ B </summary>

```javascript 
Set.prototype.intersection = function (set) {
  const result = new Set();
  for (const value of set) {
    if (this.has(value)) result.add(value)
  }
  return result;
}

const setA = new Set([1,2,3,4,])
const setB = new Set([2,4,])
console.log(setA.intersection(setB))
```

위에서 선언한 `intersection`은 일종의 `사용자 정의 프로토타입 메서드`라고 부를 수 있다. 프로토타입 메서드는 객체의 프로토타입에 직접 메서드를 추가하는 것을 말한다. `Set.prototype.intersection`은 `Set.prototype`를 통해서 `Set`에 상속한 메서드이로, 모든 Set 객체에서 사용할 수 있도록 확장시켰다. 이렇게 선언된  프로토타입 메서드는 프로토타입 체인에 의해서 객체 인스턴스에서 호출될 수 있다. 여기서 this가 호출되는 시점을 보면, intersection 안에서 this는 메서드로 호출되었기에, 전역객체가 아니라. Set 객체에 바인딩된다. 

딥다이브는 아래외 같이 스프레드 문법을 통해서 이를 더 쉽게 아래와 같이 구현한다. 

```javascript
Set.prototype.intersection = (set) => {
  return new Set([...this].filter(v => set.has(v)))
}

const setA = new Set([1,2,3,4,])
const setB = new Set([2,4,])
console.log(setA.intersection(setB))
```

두 코드의 시간복잡도를 비교해보자. 두 코드다 `this`의 숫자만큼, `set.has(v)` 매개변수로 받은 set 객체에 해당 내용이 포함되어 있는지를 순회하며 살펴본다. `has()`의 시간복잡도는 O(1)인데, `this`의 요소 수에 따라 O(n)의 시간 복잡도가 나온다. GPT 선생에 따르면 그러나 첫 코드는 `for ... of`루프를 사용하여 상수적인 오버헤드가 있을 수 있다고 한다. 

여기서 첫번째 코드가 수행하는 상수적인 오버해드는, 각 반복마다. Set 객체의 has를 호출한다는 점이다. 반면에 두번째 방법은 그 내부작업에서, `for...of`의 작업을 간결하게 수행한다. Set 객체의 요소를 배열로 복사하는 과정의 약간의 오버헤드가 있을 수 있지만, 해당 작업을 통해 생성된 배열을 비교하기 때문이라고 한다. 결과적으로 성능에 영향을 미칠 정도는 아니기에, 개발자의 스타일과 가독성으로 결정할 것을 말해준다. 

결론적으로 정리하면, 교집합은 위와 같이 Set 객체에 프로토타입으로 메서드를 추가하여, 원하는 결과를 도출해낼 수 있다는 것이다. 
</details>



<details>
<summary>2. 합집합 : A ∪ B </summary>

합집합은 주어진 두 값의 중복 없는 모든 요소를 포함한다. 

```javascript 
Set.prototype.union = function (set) {
  const result = new Set(this);
  for (const value of set) {
    result.add(value)
  }
  return result
}

// 이를 더 간단하게 구현하면 아래와 같다. 
Set.prototype.union = function (set) {
  const resutl = new Set([...this, ...set]);
}

const setA = new Set([1,2,3,4,])
const setB = new Set([2,4,])
console.log(setA.union(setB))
```
</details>

<details>
<summary>3. 차집합 : A - B </summary>

```javascript
Set.prototype.difference = function (set) {
  const result = new Set([...this])
  for (const value of set) {
    result.delete(value)
  }
  return result 
}

Set.prototype.difference = function (set) {
  return new Set([...this].filter(v => !set.has(v)))
}

const set = (array) => {
  return new Set([...array])
}

console.log([...set([2,1,2,3,4,5,6]).difference(set([2,1,2,3,4,5]))])
```

차집합으로 만들어진 배열을 만들어내기 위해서 `console.log([...set([2,1,2,3,4,5,6]).difference(set([2,1,2,3,4,5]))])`와 같이 기록함으로 Set으로 만들어진 객체를 `[...set]`으로 최종적 형반환화여 추출했다. 

여기서 선언된 메서드를 화살표함수로 전환하고자 했지만, 런타임 시에 에러가 발생되었다. 이는 메서드도 화살표함수고, set을 만드는 함수도 화살표 함수이기 떼문에 발생된 문제이다. 아래의 3가지 상황을 살펴보자. 


여기에 `this`를 살펴보기 좋은 예제가 있기에 이를 살펴보자. 
```javascript 

// 상황 (1) 정상적으로 동작한다. ///////////////////////////////////////////////////////////////////////////
function set(array) {
  return new Set([...array])
}

Set.prototype.difference = function (set) {
  return new Set([...this].filter(v => !set.has(v)))
}
console.log(set([2,1,2,3,4,5,6]).difference(set([2,1,2,3,4,5])))

// 상황 (2) 정상적으로 동작한다. ///////////////////////////////////////////////////////////////////////////
const set = (array) => {
  return new Set([...array])
}
Set.prototype.difference = function (set) {
  return new Set([...this].filter(v => !set.has(v)))
}
console.log(set([2,1,2,3,4,5,6]).difference(set([2,1,2,3,4,5])))

// 상황 (3) 런타임시 에러가 발생된다. 위와 같이 set을 함수선언문으로 작성해도, 함수표현식으로 작성해도 에러가 발생된다. ///////
function set(array) {
  return new Set([...array])
}

// 또는 
const set = (array) => {
  return new Set([...array])
}

Set.prototype.difference = (set) =>  {
  return new Set([...this].filter(v => !set.has(v)))
}

// console.log(set([2,1,2,3,4,5,6]).difference(set([2,1,2,3,4,5])))
```

먼저 상황 (1)이다. set은 함수이고,  difference 는 프로토타입으로 추가된 메소드이다. `set().difference(set())`르 호출하면, `difference 메소드`는 메소드가 호출되는 set의 인스턴스(`return new Set([...array])`)를 참조한다. 이 경우 this는 호출에 의해 생성된 Set 개체에 바인딩된다. 메서드로 호출되었기 때문이다. 

다음으로 상황 (2)은 (1)과 다르게 `화살표 함수 set은 입력 배열을 기반으로 Set 객체를 생성`한다. 그러나 `set().difference(set())`의 호출은 여전히 메소드는 호출되는 set의 인스턴스를 참조하며, Set 개체에 바인딩된다. 

그러나 `Set.prototype.difference = (set) => {}` 메서드가 화살표함수로 선언되었을 때는 이야기가 다르다. Set.prototype.difference 화살표 함수의 경우 주변 범위는 실제로 Set 생성자 함수가 정의된 전역 범위를 참조한다. 이는 화살표함수가 this를 바인딩하지 않기 때문이다. 화살표함수로 선언된 메서드는 프로토타입의 할당에 영향을 받지 않는다. 그 결과 화살표 함수에서의 this는 호출시의 전역변수에 의해 정의되기 때문에, 브라우저 환경의 window 또는 Node.js의 global)를 참조하게 되는 것이다. 그 결과 this는 Set 개체의 인스턴스를 참조하지 않으며 코드가 의도한 대로 작동하지 않게 되는 것이다. 

</details>

또는 이를 통해서 집합이 다른 집합에 포함된 것인지, 상위집합의 여부인지 판별하는 메소드를 추가할 수도 있다. 이는 딥다이브 652페이지를 참고하자. 

<br/><br/>

### 37.2 Map 자료객체 
Map 객체는 키와 값의 쌍으로 이루어진 컬렉션이다. 설명만 보면 객체와 동일해보이지만, 객체가 포함되지 않는 이터러블, 즉 순회 가능한 데이터 자료구조를 가지고 있는 것이 Map이다. 


|구분|Object|Map|
|:--|:--:|:--:|
|키로 사용할 수 있는 값|문자열 또는 심벌 값|객체를 포함한 모든 값|
|이터러블의 여부, 순회를 통해서 자료에 접근이 가능한지, `for...of`문의 사용 여부|X|O|
|요소를 확인할 수 있는지, 이터러블의 `size 메서드`의 사용유무 <br/> 객체는 객체의 키값의 길이를 통해서 접근해야 하지만, Map은 이터러블 메서드를 통해서 쉽게 정보에 도달할 수 있다. |Object.keys(obj).length|map.size|

#### 37.2.1 Map 객체의 생성
Set과 같이 Map 객체는 생성자 함수 키워드 new 와 함께 사용되어 생성되며, 인수를 전달하지 않으면 빈 Map 객체를 생성한다. Map의 인수는 이터러블로 된 요소로 구성되어야 한다. 즉 객체는 Map의 인수로 전달할 수 없다는 말이다. Map 생성자는 함수의 인수로 전달한 이터러블에 중복된 키가 있다면, 덮어지며, 그 결과 Map 객체에는 중복된 키를 갖는 요소가 존재할 수 없다. 

```javascript 
// Set과 Map은 출력되는 결과가 다르다. 
// Set (2) {1,2}
// Map (2) {"Key1" => "value1", "Key2" => "value2"}
```

그래서 Set은 Array와 비교되었고, Map은 Object와 비교된 것을 볼 수 있다. `add 메서드`를 통해서 내용을 추가하려 할 때, Set은 값만 있으면 되지만, Map은 "키-값"의 쌍으로 추가해야 한다. 이 때 이미 Map 안에 존재하는 "키"가 추가되면, 기존의 내용이 덮어써진다. 

<details>
<summary>1. Map의 매서드들(size, set)</summary>

    ```javascript
    const Map = new Map([
      ['key1', 'value1'],
      ['key2', 'value2'],
    ])

    ```

    |매서드|기능|사용예시|
    |:--:|:--:|:--|
    |mpa.size|요소 개수 확인| `console.log(map.size);` 위의 사례에서는 2가 출력된다.|
    
  
</details>