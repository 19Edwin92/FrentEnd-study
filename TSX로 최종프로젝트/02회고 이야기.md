## 이노캠모터스 회고노트

### 첫번째 이야기 
7월 21일 첫 만남으로 시작하여, 프로젝트를 진행한지 4일이 지났다. 6주라는 짧은 시간이지만, 틈틈히 회고를 남기지 않으면 공부한 기억들이 사장될 위험이 있기에, 이렇게 저금씩 공부했고, 고민했던 흔적들을 남기고자 한다. 

<details>
<summary>타입스크립트와 라이브러리, 맛보기</summary>
<br/>
가장 먼저 이야기할 부분은 `타입스크립트`에 대한 부분이었다. 이론으로 타입을 선언하는 부분에 대해서 공부했지만, 실전은 달랐다. 모든 것에 타입을 지정해주어야 했기 때문이다. 라이브러리에도 타입이 존재했으며, 해당 타입을 설정해주지 않으면 컴파일 단계에서 에러가 발생되어 아무것도 할 수 없는 상황이 되었다. 4일 동안의 짧은 기간이었지만, 그 동안의 짧은 이야기라도 기록으로 남겨, 훗날의 이를 회상하는데 도움을 주고자 한다. 

1. Axios 라이브러리의 타입적용

    리액트 JS에서는 고민없이 사용했던 라이브러리에도 타입설정이 필요했다. `인스턴스`를 생성하는 부분에도 타입설정이 필요했고, `인터셉터`를 적용하는 부분에서도 `config`와 `response`에 따라서 타입을 지정해 줘야 했다. 또한 번외의 이야기지만, `config`와 `response`를 인터셉터해서 어떤 처리를 하면, 반드시 두 요소를 return 해주어야 결과값을 전달하고 전달받는 다는 것 또한 유념해야할 이이었다. 

    ```tsx
    import axios, * as axiosType from 'axios';

    // axios 인스턴스 생성
    export const instance: axiosType.AxiosInstance = axios.create({
    baseURL: process.env.REACT_APP_SERVER_KEY,
    });

    interface MyAxiosRequestConfig extends axiosType.AxiosRequestConfig {
    headers: axiosType.AxiosRequestHeaders;
    }

    // 요청 인터셉터 설정
    instance.interceptors.request.use(
    (config: MyAxiosRequestConfig) => {
        ...
        return config;
    },
    (error) => {
        return Promise.reject(error);
    },
    );

    // 응답 인터셉터 설정
    instance.interceptors.response.use(
    (response: axiosType.AxiosResponse) => {
        ...
        return response;
    },
    (error) => {
        return Promise.reject(error);
    },
    );
    ```

2. RTK-query 라이브러리의 타입적용

    이번 4일의 작업에서 타입설정과 관련하여 가장 어려웠던 부분은 `RTK-query` 부분의 타입을 설정하는 일이었다. 특별히 `catch(error)` 부분의 타입을 지정해 주는 부분이 특별히 기억에 남는다. 반나절 정도를 찾아보고 내용을 적용시켰던 것 같다. 공식문서를 열심히 살펴보았지만, 익숙하지 않아서 어려움이 있었다. 그러나 이 과정에서 이미 라이브러리를 제공해주는 곳에서 만들어진 `index.d.ts`를 잘 살펴보는 것만으로 문제를 쉽게 접근할 수 있다는 것을 배우게 되었다. 

    ```tsx
    export const inocamRTK = createApi({
        baseQuery: axiosBaseQuery(),
        tagTypes: ['POSTS', 'POSTDETAIL', 'POSTCOMMENT'],
        endpoints(build) {}
    })
    ```

    (1) RTK-query에서 설정할 타입은 `axiosBaseQuery`부분으로 아래와 같다. 

    (2) `BaseQueryFn`를 설정함에 있어서, 개발자가 지정하고 싶은 내용을 추가로 기록할 수 있는데, 매번 포함되지 않는 요소에는 옵셔널체이닝(?)을 설정해 주었고, method와 data는 기본적으로 제공되어 있는 타입선언을 활용하면 된다. 

    ```tsx
    const axiosBaseQuery = (): BaseQueryFn<{
        url: string;
        method: AxiosRequestConfig['method']
        data?: AxiosRequestConfig['data'];
        types?: string;
    }> => async ({ url, method, data, types }) => {}
    ```

    (3) `catch (axiosError)`에 있어서의 에러타입설정 부분이 특히 어려웠다. 

    ```tsx
    catch (axiosError) {
        const err = axiosError as Type.CustomAxiosError<Type.ErrorType['data']>; // 타입단언
        return {
          error: err.response?.data.msg
        };
    }

    // responseType.d.ts
    export interface ErrorType {
        data: {
            error: boolean,
            status:number,
            msg: string
        }
    }
    export interface CustomAxiosError<T> extends AxiosError {
        response?: AxiosResponse<T>
    }
    ```

    타입가드도 생각해봤지만, 결국은 `타입단언`을 통해서 적용했다. 기존에 있었던 `AxiosError`를 상속받아서, `AxiosResponse`를 더하고, 여기에 `제네릭`을 설정했다. 그리고 이를 활용하는 부분에서 `ErrorType`를 넣어서 작업했다. 
</details>



<details>
<summary>타입스크립트와 타입선언</summary>
<br/>

타입선언은 `type`과 `interface` 두 가지 방법이 있고, 두 가지 방법은 각각의 목적과 사용 방법의 차이가 있다. 

1. `type` 알리아스(타입별칭)

    `type`은 기존 타임에 별칭을 붙여서 재사용하기 쉬운 커스텀 타입을 만들 때 유용한다. 타입의 확장은 아래와 같이 가능하다. 

    ```tsx
    type Person = {
        name: string;
        age: number;
    };

    type MyIntersection = Person & { email: string };
    ```

2. `interface` 객체의 구조를 정의한다. 

    주로 객체 간의 상호 작용을 명시적으로 지정하거나, 클래스가 구현해야 하는 메서드와 속성을 정의하는데 사용한다. 결국에는 성향차이라고 하는데, 일반적으로 별칭은 간단하고 범용적인 타입 선언에 적합하며, 인터페이스는 객체 간의 상호 작용과 클래스 구현에 더 적합한 것으로 구분하여 사용한다. 아래는 이번 프로젝트에서 사용한 `interface` 정의 목록이다. 범용적으로 사용하기 위해 타입을 구분했고, 각각의 상황에 따라서 사용할 수 있도록, export 해주었다. 

    ```tsx
    export interface CommentsData {
        comment_id: number;
        nickname: string;
        comment: string;
        created_at: string;
        modified_at: string;
    }

    export interface PostPosts {
        title:string;
        content:string;
        post_id?: number;
    }

    export interface PostsData extends PostPosts {
        is_like: boolean;
        like_count: number;
        comment_count?: number;
    }

    export interface PostsDetailData extends PostsData {
        image_urls: string[];
        comment: CommentsData[];
    }   
    ```

3. 컴포넌트의 props에 대한 타입지정

    ```tsx
     return (<EditCommunityDetail post_id={post_id} title={title} content={content} />)

     export const EditCommunityDetail: React.FC<Type.PostPosts> = ({ post_id, title, content }) => {

        return <div>로그인 ...</div>
     }
    ```
</details>


<details>
<summary>상태관리와 RTK-query, MSW</summary>
<br/>

상태관리는 언제나 어려운 주제이다. Redux, ContextAPI, 그리고 Recoil 등이 큰 축인 것 같다. 그리고 네트워크 통신과 관련해서는 RTK-createAysnsThunk, React-query, RTK-query 등으로 접근이 가능할 것이다. 

먼저, RTK-createAysnsThunk는 리덕스를 기반으로 확장되었다는 점에서 장점이 있다. 하지만, isLoading, isError 등의 상황을 모두 직접 기록해야 한다는 점과, 저장 위치가 메인 메모리에 저장된다는 점에서 다소 불편함이 있다. 

React-query는 네트워크 전용 상태관리를 표망하며, 비동기 통신 전용의 상태관리 라이브러리이다. 데이터를 캐시에 저장하여 효율적으로 데이터를 캐싱하고 패싱한다. 그러나 로직이 분산되어 있다는 한계는 있다. 

이번 프로젝트에서 채택한 RTK-query는 리덕스가 가진 중앙집중화의 장점을 가지고 API를 구현한다. 또한, 데이터를 React-query 처럼 캐시에 저장하여 효율적으로 데이터를 관리한다. 

이번 프로젝트에서는 axios + RTK-query + MSW를 통한 테스트 서버를 구현하여 빠르게 개발을 진행하도록 시도하였다. 

```tsx
export const inocamRTK = createApi({
  baseQuery: axiosBaseQuery(),
  tagTypes: ['POSTS', 'POSTDETAIL', 'POSTCOMMENT'],
  endpoints(build) {
    return {
      // loginRTK
      postLogin: build.mutation({
        query: (data) => ({
          url: '/api/auth/login',
          method: 'post',
          data,
          types: 'login',
        }),
      }),
      // Signup
      postSignup: build.mutation({
        query: (data) => ({
          url: '/api/auth/signup',
          method: 'post',
          data,
          types: 'signup',
        }),
      }),
      // getEmailCheck
      getEmailCheck: build.query({
        query: (email) => ({
          url: `/api/auth/email?email=${email}`,
          method: 'get',
          types: 'getCheck',
        }),
      }),
      // getNickNameCheck
      getNickCheck: build.query({
        query: (nickname) => ({
          url: `/api/auth/nickname?nickname=${nickname}`,
          method: 'get',
          types: 'getCheck',
        }),
      }),

      // getPosts - 차량출고 커뮤니티
      getPosts: build.query({
        query: () => ({
          url: `/api/posts`,
          method: 'get',
          types: 'getData',
        }),
        providesTags: ['POSTS']
      }),

      // postPosts - 차량출고 커뮤니티
      postPosts: build.mutation({
        query: (data) => ({
          url: `/api/posts`,
          method: 'post',
          data,
          types: 'multipart',
        }),
        invalidatesTags: ['POSTS']
      }),

      // DeletePosts - 차량출고 커뮤니티 게시글 삭제
      DeletePosts: build.mutation({
        query: (postId) => ({
          url: `/api/posts/${postId}`,
          method: 'delete',
        }),
        invalidatesTags: ['POSTS']
      }),

      // EditPosts - 차량출고 커뮤니티 게시글 수정
      patchPosts: build.mutation({
        query: ({postId, formData}) => ({
        url: `/api/posts/${postId}`,
        method: 'patch',
        data:formData,
        types:'multipart'
      }),
      invalidatesTags: ['POSTS', "POSTDETAIL"]
      }),


      // getPostsDetail - 차량출고 커뮤니티 게시글
      getPostsDetail: build.query({
        query: (postId) => ({
          url: `/api/posts/${postId}`,
          method: 'get',
          types: 'getData',
        }),
        providesTags: ['POSTDETAIL']
      }),

      // postComment - 차량출고 커뮤니티 댓글작성
      postComment: build.mutation({
        query: ({postId, data}) => ({
          url: `/api/posts/${postId}/comments`,
          method: 'post',
          data
        }),
        invalidatesTags: ['POSTDETAIL']
      }),


    };
  },
});

export const {
  // Auth
  usePostLoginMutation,
  usePostSignupMutation,
  useGetEmailCheckQuery,
  useGetNickCheckQuery,

  // Posts 차량출고 커뮤니티 관련
  useGetPostsQuery,
  usePostPostsMutation,
  useDeletePostsMutation,
  usePatchPostsMutation,
  useGetPostsDetailQuery,
  usePostCommentMutation,
} = inocamRTK;
```

중앙집중화 되어 있다는 점에서 `하나의 API`를 생성하는데 단 몇 분밖에 걸리지 않고, 쉽고 간편하게 useOOOQuery, useOOOMutation을 통해 호출하여 사용할 수 있다. 나아가 get 요청의 경우 조건부로 할 수 있을까 고민을 하게 되었다. 이전 프로젝트에서 React-query 를 했을 때, 사용했던 기억이 있는데 RTK-query도 간편하게 사용할 수 있었다. 

```tsx
 const { 
    isSuccess: checkEmailSuccess, 
    data: checkEmailData, 
    isError: checkEmailError, 
    error: emailError } = useGetEmailCheckQuery(signInfo.email, {skip: checkEmail})
```

`skip`에 들어가는 상태에 따라서 get요청을 제어할 수 있다. `true`를 하면 get요청이 무시된다. 이를 `false`로 변경될 때 요청이 시작된다. 이를 통해서 이메일체크와 닉네임체크 부분을 원하는 호출시점에 제어함으로 개발목적과 의도에 따라 동작하게 하였다. 

```tsx
  const onChangeInput = (e: ChangeEvent<HTMLInputElement>): void => {
    const { name, value } = e.target
    setSignInfo({ ...signInfo, [name]: value })
    setCheckEmail(true)
    setCheckNickName(true)
  }  
```

나아가 새로운 입력에 대한 이벤트가 발생되었을 때에는 이를 다시 true 로 번경하여 호출되지 않도록 제한하였다. 

### 이번에는 MSW이다. 

MSw는 정말 막강하다. API 배포와 디자인 가이드가 나오지 않는 시점에서 빠르게 코드를 테스르 하여, 서버통신을 가정한 상태로 개발을 진행할 수 있었고 그 결과는 대단했다. 다음은 이제 스타일드 컴포넌트를 모듈화하면 될 것 같다. 이후는 이제 생성한 모듈을 실제로 그리는 일만 남았다. 

```tsx
import { rest } from 'msw';
import * as TestDB from './testData';
import * as Type from '../types';


export const handlers = [
  // Login
  rest.post<Type.User>(`${process.env.REACT_APP_SERVER_KEY}/api/auth/login`,
    async (req, res, ctx) => {
      const request = req.body;
      const find = TestDB.logindata.find(user => user.email === request.email)

      if (find && request.password === find.password) {
        return res(
          ctx.status(200),
          ctx.json({
            success: true,
            status: 200,
            msg: '로그인성공',
          }),
          ctx.set(
            'authorization',
            'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5',
          ),
        );
        // 배열에서 존재하지 않으면...   
      } else if (find && request.password !== find.password) {
        return res(
          ctx.status(401), // 인증되지 않음
          ctx.json({
            error: true,
            status: 401,
            msg: '비밀번호가 틀렸습니다.',
          }),
        );
        // 배열은 있는데 비밀번호가 틀린 경우
      } else {
        return res(
          ctx.status(401), // 인증되지 않음(리소스에 없음) 
          ctx.json({
            error: true,
            status: 401,
            msg: '존재하지 않는 이메일 입니다.',
          }),
        );
      }
    },
  ),

  // Signup
  rest.post<Type.UserInfo>(`${process.env.REACT_APP_SERVER_KEY}/api/auth/signup`,
    async (req, res, ctx) => {
      const request = req.body;
      TestDB.logindata.push(request)
      return res(
        ctx.status(200),
        ctx.json({
          success: true,
          status: 200,
          msg: '회원가입성공',
        }),
      );
    }
  ),

  // Signup-emailCheck
  rest.get<Type.UserInfo>(`${process.env.REACT_APP_SERVER_KEY}/api/auth/email`,
    async (req, res, ctx) => {
      const checkEmail = req.url.searchParams.get('email')
      const find = TestDB.logindata.find(user => user.email === checkEmail) || null
      if (!find) {
        return res(
          ctx.status(200),
          ctx.json({
            success: true,
            status: 200,
            msg: '사용 가능한 이메일 입니다.'
          }),
        );
      } else {
        return res(
          ctx.status(409), // 이미 리소스 상에 존재하면
          ctx.json({
            error: true,
            status: 409,
            msg: '이미 존재하는 이메일 입니다.',
          }),
        );
      }
    }
  ),

  // Signup-NickNameCheck
  rest.get<Type.UserInfo>(`${process.env.REACT_APP_SERVER_KEY}/api/auth/nickname`,
    async (req, res, ctx) => {
      const checkNickName = req.url.searchParams.get('nickname')
      const find = TestDB.logindata.find(user => user.nickname === checkNickName) || null
      if (!find) {
        return res(
          ctx.status(200),
          ctx.json({
            success: true,
            status: 200,
            msg: '사용 가능한 닉네임 입니다.'
          }),
        );
      } else {
        return res(
          ctx.status(409), // 이미 리소스 상에 존재하면
          ctx.json({
            error: true,
            status: 409,
            msg: '이미 존재하는 닉네임 입니다.',
          }),
        );
      }
    }
  ),

  // getPosts - 차량출고 커뮤니티 
  rest.get(`${process.env.REACT_APP_SERVER_KEY}/api/posts`,
    async (_, res, ctx) => {
      return res(
        ctx.status(200),
        ctx.json({
          success: true,
          status: 200,
          msg: '게시글이 조회되었습니다.',
          data: TestDB.postdata
        }),
      );
    }
  ),

  // getPosts - 차량출고 커뮤니티 게시글 조회 
  rest.get(`${process.env.REACT_APP_SERVER_KEY}/api/posts/`, // ${postId}
    async (_, res, ctx) => {
      return res(
        ctx.status(200),
        ctx.json({
          success: true,
          status: 200,
          msg: '게시글이 조회되었습니다.',
          data: TestDB.postdata
        }),
      );
    }
  ),

  // getPostDeatil - 차량출고 커뮤니티 게시글 조회 
  rest.get(`${process.env.REACT_APP_SERVER_KEY}/api/posts/:id`,
    async (req, res, ctx) => {
      const find = TestDB.postDetailData.find(post => post.post_id === +req.params.id)
      return res(
        ctx.status(200),
        ctx.json({
          success: true,
          status: 200,
          msg: '게시글이 조회되었습니다.',
          data: [find]
        }),
      );
    }
  ),

  // postPosts - 차량출고 커뮤니티 
  rest.post(`${process.env.REACT_APP_SERVER_KEY}/api/posts`,
    async (_, res, ctx) => {
      return res(
        ctx.status(200),
        ctx.json({
          success: true,
          status: 200,
          msg: '게시글이 등록이 등록되었습니다.'
        }),
      );
    }
  ),

  // deletePosts - 차량출고 커뮤니티 게시글 삭제
  rest.delete(`${process.env.REACT_APP_SERVER_KEY}/api/posts/:id`,
    async (req, res, ctx) => {
      const findIndex = TestDB.postdata.findIndex((post: Type.PostsData) => post.post_id === +req.params.id)
      TestDB.postdata.splice(findIndex, 1)

      return res(
        ctx.status(200),
        ctx.json({
          success: true,
          status: 200,
          msg: '게시글이 삭제되었습니다.'
        }),
      );
    }
  ),

// patchPosts - 차량출고 커뮤니티 게시글 수정
rest.patch(`${process.env.REACT_APP_SERVER_KEY}/api/posts/:id`,
async (req, res, ctx) => {
  console.log("patchPosts", req);
  return res(
    ctx.status(200),
    ctx.json({
      success: true,
      status: 200,
      msg: '게시글이 수정되었습니다.'
    }),
  );
}
),

// postPostsComment - 차량출고 커뮤니티 게시글 댓글작성
rest.post(`${process.env.REACT_APP_SERVER_KEY}/api/posts/:id/comments`,
async (req, res, ctx) => {
  console.log("patchPosts", req.body);
  return res(
    ctx.status(200),
    ctx.json({
      success: true,
      status: 200,
      msg: '댓글이 입력 되었습니다.'
    }),
  );
}
),

// deletePostsComment - 차량출고 커뮤니티 게시글 댓글작성
rest.delete(`${process.env.REACT_APP_SERVER_KEY}/api/posts/:postid/comments/:commentid`,
async (req, res, ctx) => {
  console.log("deletePostsComment", req.params.id);
  return res(
    ctx.status(200),
    ctx.json({
      success: true,
      status: 200,
      msg: '댓글이 삭제 되었습니다.'
    }),
  );
}
),

// postPostsComment - 차량출고 커뮤니티 게시글 댓글작성
rest.patch(`${process.env.REACT_APP_SERVER_KEY}/api/posts/:postid/comments/:commentid`,
async (req, res, ctx) => {
  console.log("patchPosts", req.params.id, req.body);
  return res(
    ctx.status(200),
    ctx.json({
      success: true,
      status: 200,
      msg: '댓글이 수정 되었습니다.'
    }),
  );
}
),
];
```
</details>

<details>
<summary>타입스크립트와 유틸리티 : Partial</summary>

타입스크립트에는 타입을 조작할 수 있는 유틸리티 타입이 존재한다. 그 가운데 3 가지를 소개하고자 한다. 

1. Partial 타입이다. 

    아래는 실제 프로젝트에서 `스타일드 컴포넌트`의 타입을 설정하며 고민했던 내용의 결과이다. 처음에는 계속해서 `interface`를 생성하고, 그 안에 `옵셔널`로 타입을 정의하려고 했었다. 그 결과 모든 타입정의에 `옵셔녈`이 들어가게 되는 상황이 발생되었고, 과연 이것이 효율적인가 고민하게 되었다. 또한 반복되는 타입들의 중복을 제거하고자 하는 욕심도 있었다. 
    
    중복을 제거하면서, 타입검사를 느슨하게 만드는 옵셔널을 피하면서 타입을 정의하는 방법이 있을까 고민하던 가운데, `Partial`을 찾게 되었다. 유틸리티 타입은 바로 이럴 때 사용되는 것 같다. Partial는 모든 요소를 옵셔널로 지정한 타입으로 만들어낸다. 그러기에, 실제 사용하는 타입선언에서는 필요한 내용만을 꺼내서 사용한다. 

    `옵셔널`로 만든다는 것은 동일한 내용 같은데 무엇이 다를까? 옵셔널로 지정하는 사례는 타입정의를 변경하여 선택적으로 만들어내지만, `Partial`은 새로운 타입을 생성하여 선택적으로 만들어낸다. 즉 이미 존재하는 타입에 대해 선택적인 버전을 생성하기에 기존 타입 정의를 변경하지 않고 유연하게 다룬다는 점이 다르다. 즉  `Partial` 타입은 기존 타입을 복제하여 각 속성을 선택적으로 만들기 때문에 타입 정의를 반복하지 않고도 선택적인 타입을 쉽게 만들 수 있습니다.

    ```tsx
    export interface Styled {
      // commen
      $color:string;
      $width:string;
      $height:string;

      // Felx-Grid
      $gap: number;

      // Flex
      $fd: string;
      $jc: string;
      $ai: string;

      // Grid
      $gtc:string;
      $gtr:string;
      $gar:string;
      $cgap: number;
      $rgap: number;

      // GridMergedSpace
      $mergedgcs: number
      $mergedgce: number
      $mergedgrs: number
      $mergedgre: number
    }
    ```

  이에 대한 GPT의 평가는 아래와 같다. 

  (1) 선택적인 Props : 필요한 속성만을 전달함으로 불필요한 속성을 생략하고 간단한 인터페이스로 컴포넌트를 사용할 수 있다고 한다. 

  (2) 재사용성 :  스타일드 컴포넌트를 사용하는 다른 컴포넌트들에서도 동일한 Styled 인터페이스를 사용할 수 있으며, `Partial<Styled>`을 이용하여 필요한 스타일 속성을 선택적으로 전달할 수 있게된다. 이로 인해 스타일드 컴포넌트를 쉽게 재사용할 수 있다. 

  (3) 타입 안정성 : `Partial<Styled>`는 타입 안정성을 제공한다. 컴파일러가 타입 검사를 수행하여 부적절한 속성을 사용하려는 시돌르 방지하고 잘못된 타입으로 인한 오류를 줄여준다. 

  (4) 코드 가독성 : `Partial<Styled>`을 사용하면 필요한 속성을 명시적으로 선택하여 코드의 가독성이 높아진다. 

  (5) 유지보수성 : 스타일드 컴포넌트의 props를 유연하게 다루면 스타일이 변견되거나 추가되는 경우에도 코드 수정이 간단해진다. 새로운 스타일 속성을 추가하기 위해 인터페이스를 추가하는 대신, 해당 속성을 `Partial<Styled>`에 추가하여 필요한 곳에서 선택적으로 사용할 수 있게 만들기 때문이다. 

  정리하면, `Partial<Styled>`를 사용하녀 스타일드 컴포넌트의 props를 선택적으로 만드는 접근 방식은 코드의 유연성, 재사용성, 가독성 및 유지 보수성을 향상시키는 좋은 방법이다. 

  아래는 실제 스타일드 컴포넌트에서 해당 내용을 적용한 사례이다. 

  ```tsx
  /* About Div styled ---------------------------------------------- */
  const FlexBox = sc.styled.div<Partial<Styled>>`
    ${Flex}
  `;

  const GridBox = sc.styled.div<Partial<Styled>>`
    ${Grid}
    background-color:${({$color}) => $color};
  `

  const GridMergedSpace = sc.styled.div<Partial<Styled>>`
    grid-column-start: ${({$mergedgcs}) => $mergedgcs ? $mergedgcs : "auto"};
    grid-column-end: ${({$mergedgce}) => $mergedgce ? $mergedgce : "auto"}; // span 2;
    grid-row-start: ${({$mergedgrs}) => $mergedgrs ? $mergedgrs : "auto"};
    grid-row-end: ${({$mergedgre}) => $mergedgre ? $mergedgre : "auto"}; // span 3;
  `

  const FigureImg = sc.styled.figure<Partial<Styled>>`
    width: ${({ $width }) => $width};
    img {
      display: block;
      width: 100%;
    }
  `;
  ```
</details>


<details>
<summary>CSS와 그리드</summary>

<img src="../img/정규스크럼(3).gif">

```tsx
const GridBox = sc.styled.div<Partial<Styled>>`
  ${Grid}
  background-color:${({$color}) => $color};
`

const GridMergedSpace = sc.styled.div<Partial<Styled>>`
  grid-column-start: ${({$mergedgcs}) => $mergedgcs ? $mergedgcs : "auto"};
  grid-column-end: ${({$mergedgce}) => $mergedgce ? $mergedgce : "auto"}; // span 2;
  grid-row-start: ${({$mergedgrs}) => $mergedgrs ? $mergedgrs : "auto"};
  grid-row-end: ${({$mergedgre}) => $mergedgre ? $mergedgre : "auto"}; // span 3;
`
```

이번 프로젝트를 진행하며, CSS-display-grid에 대한 이해를 보다 높이는 시간이 되었다. 레이아웃 구성에 있어서 그리드는 단연 최고의 속성인 것 같다. 그리드를 연습하며 (1) 레이아웃에 `GridBox`를 선언했고, (2) 내부를 제어하기 위해서 `GridMergedSpace`를 통해서 행과 열의 시작점과 끝점을 설정하여 위치를 조절해 주었다. 

아래의 코드는 위의 그리드 박스를 제어한 컴포넌트의 코드이다. 

- $mergedgcs={2} 
- $mergedgce={5} 
- $mergedgrs={4} 

FE팀에서 설정한 `$mergedgcs`, `$mergedgce`, `$mergedgrs`, `$mergedgre`의 값에 따라서 그리드 내부의 요소의 위치를 조절하여 원하는 위치에 원하는 크기로 설정하게 하였다. 

그리드박스 안에있는 요소들의 각 너비와 높이는 FE팀에서 설정한 속성에 따라서 `<GridBox $gtc="repeat(auto-fill, minmax(25%, auto))" $gar="minmax(200px, auto)">`와 같이 지정해 줌으로 최소값을 지정해 주었다. 

```tsx
import React from 'react';
import { styled } from 'styled-components';
import { FlexBox, GridBox, GridMergedSpaceFlex } from '../../components';

export const DecorationDetail: React.FC = () => {
  return (
    <GridBox $gtc="repeat(auto-fill, minmax(25%, auto))" $gar="minmax(200px, auto)">
      <GridMergedSpaceFlex $mergedgcs={2} $mergedgce={5} $mergedgrs={4} style={{ backgroundColor: "red" }}>나요 </GridMergedSpaceFlex>
      <FlexBox style={{ backgroundColor: "lightcoral" }}>아</FlexBox>
      <FlexBox style={{ backgroundColor: "lightcoral" }}>아</FlexBox>
      <FlexBox style={{ backgroundColor: "lightcoral" }}>아</FlexBox>
      <FlexBox style={{ backgroundColor: "lightcoral" }}>아</FlexBox>
      <FlexBox style={{ backgroundColor: "lightcoral" }}>아</FlexBox>
      <FlexBox style={{ backgroundColor: "lightcoral" }}>아</FlexBox>
      <FlexBox style={{ backgroundColor: "lightcoral" }}>아</FlexBox>
      <FlexBox style={{ backgroundColor: "lightcoral" }}>아</FlexBox>
      <FlexBox style={{ backgroundColor: "lightcoral" }}>아</FlexBox>
      <FlexBox style={{ backgroundColor: "lightcoral" }}>아</FlexBox>
      <FlexBox style={{ backgroundColor: "lightcoral" }}>아</FlexBox>
      <FlexBox style={{ backgroundColor: "lightcoral" }}>아</FlexBox>
      <FlexBox style={{ backgroundColor: "lightcoral" }}>아</FlexBox>

    </GridBox>
  );
};
```

</details>


<details>
<summary>프로그레시브 웹앱 : PWA</summary>

배경은 웹 vs 앱이라는 진부한 싸움을 종료하고, 웹의 장점은 그대로 유지하면서 네이트브 앱의 강점으로 무장한 네이티브 앱의 강력한 기능성과 웹의 뛰어난 접근성을 모두 갖춘 가징 이상적인 형태의 웹앱이라는 개념을 2015sus 구글 크롬 엔지니어인 알렉스 러설이 고안한 개념이다. 

- Y축 : 사용자경험(앱)
- X축 : 접근성(웹)
- 둘다를 충족하는 개념으로서의 PWA : 네이트브 앱 + 모바일 웹뱁 + 하이브리드앱의 강점을 포함하는 앱

본질은 웹이지만, 앱처럼 사용할 수 있어야 한다는 것이다. 목표는 네이티브 앱과 같은 사용자 경험을 제공하는 것이다. 앱을 향해 나아가고 있다는 `철학적 관점에서 progressive` 라고 한다. 

|구분|장점|단점|
|:--|:--|:--|
|개발|이미 익숙한 웹 기술을 그대로 이용할 수 었다. HTML,CSS, JS -> 푸시알림, 오프라인 캐시 등|하드웨어 사용은 웹 API를 통하므로, 웹 표준을 지원하는 브라우저가 필요|
|배포|웹 브라우저만 있으면 어디든 배포할 수 있다, 홈 화면 설치로 OS 응용프로그램으로 설치할 수 있다.|앱스토어, 플레이 스토어를 이용할 수 없다.|
|사용|빠른 실행속도로 네이티브 앱과 유사한 사용자 경험을 제공|안드로이드, 윈도우 OS는 PWA의 모든 기능을 사용할 수 있으나, IOS는 일부로 제한된다.|


1. 프로그레시브 웹앱 : 대표하는 6가지 핵심 기술
- 필수요소 : 서비스 워커, 웹앱 매니페스트, HTTPS
- 중요기능 : 푸시알림, 홈 화면에 추가, 웹API

첫쨰, 서비스 워커 :: `웹 페이지와는 분리되어 항상 실횅되는 백그라운드 프로그램`, PWA의 심장
웹 브라우저는 기본적으로 서버를 통해서 화면을 표시합니다. PWA는 그 사이에서 `서비스 워커`위 위치를 둔다. 그 결과 항상 백그라운드에서 실행되기에, 알림을 받을 수 있게 되는 것이다. 

둘쨰, PWA의 여권 :: `웹앱 매니페스트`, 앱 소개 정보와 기본 설정을 담은 JSON 파일 

셋쨰, 전재는 HTTPS 여야 한다. 


[참고자료, elice](https://elice.io/newsroom/pwa_2)

</details>


### 두번째 이야기 
<details>
<summary>WebRTC란? (1)</summary>

1. [공식문서](https://webrtc.org/?hl=ko)

    WebRTC를 사용하면 개방형 표준 외에 작동하는 실시간 통신 기능을 애플리케이션에 추가할 수 있다. 동영상, 음성, 일반 데이터를 동종 앱 간에 전송할 수 있어 개발자가 강력한 음성 및 영상 통신 솔루션을 구축할 수 있다. WebRTC 프로젝트는 오픈소스이며, 애플, 구글, 마이크로소프트, 모질라 등의 지원을 받으며, Google WecRTC 팀에서 관리하는 페이지입니다. 

2. WebRTC의 기능

    WebRTC의 사용 사례는 카메라 또는 마이크를 사용하는 기본 웹 앱부터 고급 영상 통화 애플리케이션 및 화면 공유에 이르기까지 다양하다.

3. 리액트에서의 WebRTC 

    [kbs77](https://kbs77.tistory.com/102)의 설명에 따르면, Peer A가 먼저 Room에 들어왔는 상태이고, Peer B가 Room에 접속을 했다고 가정하고 시작한다고 한다. 

    - Peer A
      - getUserMedia : 브라우저에서 미디어 스트림을 받는다. 
      - addStream : stream을 등록한다. 
      - createOffer -> setLocalDescription : CreateOffer 후에 Local sdp를 설정한다. 
      - Send Offer : Peer B에 offer를 전달한다.<br/><br/>
    - Peer B
      - Offer를 받으면
        - setRemoteDescription : Peer A에게서 받은 Offer(sdp)로 remote sdp를 설정한다.   
        - getUserMedia : 브라우저 미디어 스트림을 받는다. 
        - createOffer -> setLocalDescription : CreateOffer 후에 Local sdp 설정한다. 
        - Send answer : Peer에게 answer를 보낸다. 
        - setRemoteDescrition : Peer에서는 answer를 전달받고 remote sdp를 설정한다. <br/><br/>

    - create-answer 과정이 끝나면, `icecandidate`로 네트워크 정보를 교환한다.
      - (요청) send candidate : 요청자에게 candidate를 보낸다. 
      - (수신) send candidate : 연결할 Peer에서 받은 정보를 저장하고 자신의 candidate를 보낸다.
      - addICECandidate : 받는 쪽에서 해당 candidata를 저장합니다. <br/><br/>

    이러한 과정을 통해서, 두 피어간의 연결이 완료되게 된다. 

4. 프론트코드 구현하기, [kbs77](https://kbs77.tistory.com/102) 코드

    ```tsx 
    import { useRef } from "react";
    import { useParams } from "react-router-dom";
    import { Socket, io } from "socket.io-client";

    const VideoCall = () => {
      // useRef를 통해서 상태다루기 
      const socketRef = useRef<Socket>(); // 소켓정보를 담을 Ref
      const myVideoRef = useRef<HTMLVideoElement>(null); // 자신의 비디오
      const otherVideoRef = useRef<HTMLVideoElement>(null); // 다른사람의 비디오
      const peerRef = useRef<RTCPeerConnection>(); // peerConnection
      
      const {roomName} = useParams(); // 특정화면에서 방으로 진입시 해당 방의 방번호를 url parameter를 전달했다. 
      
      useEffect(() => {
        socketRef.current = io("localhost:3000");
        
        // peerConnection 생성
        peerRef.current = new RTCPeerConnection({
          iceServers: [
            {
              urls: "stun:stun.l.google.com:19302",
            },
          ],
        });
      }, [])

      return (
        <div>
          <video ref={myVideoRef} autoPlay />
          <video ref={remoteVideoRef} autoPlay />
        </div>
      );
    };

    export default VideoCall;
    ```

    `RTCPeerConnection`는 별도의 라이브러리를 다운받을 필요가 없으며, 모던 웹 브라우저에 내장된 API로서, 플러그인이나 외부 라이브러리 없이 오디오, 비디오 및 데이터 공유 등의 실시간 통신을 가능하게 한다. 프로세스를 단순화하기 위해서 리액트에서는 `SimplePeer, PeerJS` 등이 있으며, 해당 라이브러리를 사용하면 WebRTC 연결 관리가 쉬워지며 시그널링과 스트림 관리와 같은 추가 기능을 제공할 수 있다. WebRTC에 대한 이해가 없다면, 라이브러리를 사용하여 빠른 개발을 하는 것이 복잡성 관리 측면에서 유용하다. 

    `iceServers`는 RTCPeerConnection로 생성된 인스턴스로, Google의 공용 STUN 서버를 사용하며, 이 서버는 WebRTC 연결의 초기 설정(NAT 트래버스)을 돕는다. 

    - 해당 코드에서는 연결즉시 WebSocket을 연결하지만(socketRef.current = io("localhost:3000"))
    - `peerRef.current`에 대한 사용은 누락되어 있다. 

    #### 다음은 해당 코드를 기반으로 하는, getMedia()로 자신의 영상정보를 가져오는 코드이다. 

    ```tsx
    const getMedia = async () => {
      try {
            // 자신이 원하는 자신의 스트림정보
            const stream = await navigator.mediaDevices.getUserMedia({
                    video: true,
                    audio: true,
                  });

            if(myVideoRef.current){
              myVideoRef.current.srcObject = stream
            }

            // 스트림을 peerConnection에 등록
            stream.getTracks().forEach((track) => {
              if (!peerRef.current) {
                return;
              }
              peerRef.current.addTrack(track, stream);
            });
            
            // iceCandidate 이벤트 
            peerRef.current.onicecandidate = (e) => {
              if (e.candidate) {
                if (!socketRef.current) {
                  return;
                }
                console.log("recv candidate");
                socketRef.current.emit("candidate", e.candidate, roomName);
              }
            };
        
            // 구 addStream 현 track 이벤트 
            peerRef.current.ontrack = (e) => {
              if (otherVideoRef.current) {
                otherVideoRef.current.srcObject = e.streams[0];
              }
            };   
        } catch (e) {
          console.error(e)
        }

    }
    ```
    
    - `navigator.mediaDevices.getUserMedia` : 해당 메소드는 HTML5부터 제공되는 최신기능이다. 즉 브라우저별 호환 대책에 미흡하다는 한계는있다. 그러나 크롬, 파이어폭스의 최신 버전(Chrome 21, Opera 18 및 Firefox 17부터 지원)을 사용한다면 문제 없다. [web.dev](https://web.dev/getusermedia-intro/)에 따르면, `getUserMedia`는 웹 앱이 사용자의 카메라와 마이크에 액세스 할 수 있도록 하는 새로운 API이다. 또한 해당 메소드는 WebRTC의 게이트웨이이기 때문에 WebRTC와 깊은 관련이 있다. 

      - 해당 메소드를 사용하면 플러그인 없이 웹캠과 마이크 입력을 활용할 수 있다. 카메라 액세스는 설치가 아니라 전화로 가능하게 된 것이다. 
      - `getUserMedia` 호출이 성공적이라면, 로컬 미디어 스트림을 얻게 된다. 해당 함수는 `await`를  사용하여, `getUserMedia`의 프로미스가 해결될 때가지 기다린다. 
      - `srcObject` : 비디오 엘리먼트의 최신 속성으로 사용되는 특수한 속성으로, 비디오 앨리먼트에 대한 미디어 소스를 설정하는데 사용된다. 
      - `autoPlay` : 비디오 엘리먼트의 autoPlay는 미디어가 로드되면 자동으로 재생되어야 함을 나타낸다. 사용자의 조작 없이 자동으로 재생된다. 
    - `stream.getTracks().forEach`는 stream객체에서 사용 가능한 모든 미디어 트랙들을 가져오는 메소드이며, 반복을 통하여, 각 원소들을 위에서 RTCPeerConnection의 인스턴스로 생성한 peerRef.current 안에 해당 트랙을 추가한다. 이로서 peerRef(RTCPeerConnection의 인스턴스)는 `사용자로부터 로컬 미디어 스트림에 있는 비디오와 오디오 트랙을 포함하게` 된다. 이를 통해 피어 연결을 설정하고, 해당 피어 연결을 통해 다른 참가자와 비디오 통화를 할 준비를 마련한다. 
    - `peerRef.current.onicecandidate`는 RTCPeerConnection 객체에 생성된 `ICE candidata`가 발견되었을 때 해당 candidata를 서버로 보내는 역할을 하게 된다. 이를 통해 서버는 해당 candidata를 다른 참가자에게 전달하여 피어 간 연결을 수립하고, 비디오 통화를 성공적으로 수행할 수 있게 한다. 
      - `Interactive Connectivity Establishment` : 위키백과 : 양방향 연결추구, 두 대의 컴퓨터가 가능한 한 직접 서로 대화하는 방법을 찾기 위해 컴퓨터 네트워킹 에서 사용하는 기술
      - 여기서 WebRTC의 문맥에서 `candidata`란 ICE(Interactive Connectivity Establishment) 후보자를 의미한다. ICE는 WebRTC에서 두 기기 간에 인터넷을 통해 피어 간 연결을 수립하는 데 사용되는 프레임워크로, 이 연결을 통해서 오디오와 비디오 스트리밍과 같은 실시간 통신이 가능해지는 것이다. ICE 후보자 수집 및 협상 프로세스는 WebRTC에서 중요한 역할을 한다. 이를 통해 기기들은 복잡한 네트워크 환경에서 가장 적합하고 효율적인 통신 방식을 찾아내어 실시간 통신 애플리케이션의 성공률과 품질을 크게 향상시킬 수 있게 된다. 
      - `onicecandidate` 이벤트 핸들러는 `e` 매개변수를 가지는데, 웹소켓을 통해서 해당 정보를 서버로 전달한다. `socketRef.current.emit("candidate", e.candidate, roomName);` 

    - `peerRef.current.ontrack`는 원격 피어(상대방)로부터 수신된 스트림을 준비하여 사용할 수 있을 때 발생한다. 요약하면 RTCPeerConnection 객체에서 원격 피어로부터 수신된 비디오 스트림을 확인하고, 이를 otherVideoRef.current로 참조된 비디오 엘리먼트에 연결하여 원격 비디오를 표시하시하여,사용자는 자신의 비디오와 함께 원격 참가자의 비디오를 실시간으로 보게 되는 것이다. 

5. WebRTC의 핵심 `RTCPeerConnection`

    RTCPeerConnection는 WebRTC를 사용하여 피어 간 연결을 수립하는데 사용되는데, WebRTC의 핵심적인 역할을 담당하는 객체이다. 다른 기기와 실제로 통신할 수 있는 연결을 설정하는 데 사용된다. 이 객체는 `로컬 미디어 스트림`과 `원격 피어로부터 수신한 스트림`을 연결하고 데이터를 교환할 수 있게 한다. 이 과정에서 RTCPeerConnection는 `ICE 후보자`를 수집하고, 원격 피어와의 연결을 협상하고, 가장 적절한 통신 경로를 결정하는 역할을 담당한다. 

    즉 위의 코드를 정리하면 결국 3가지 이다. 
    (1) 사용자로부터 사용자의 미디어 정보를 받는 일이다. => peerRef.current는 RTCPeerConnection의 인스턴스입니다. 이로써 Peer A(사용자)는 웹RTC 통화 중 Peer B(원격 피어)에게 자신의 비디오와 오디오를 전송할 준비가 되게 됩니다.
    (2) 이를 통해 Peer를 생성하고, 웹소켓을 통해 전달한다. => socketRef.current.emit()을 사용하여 생성된 ICE 후보자를 서버로 보낸다. 
    (3) 상대방의 Peer를 웹소켓을 통해 전송받아, 화면에 송출한다. =>  Peer B로부터 비디오와 오디오 스트림을 수신하여, otherVideoRef.current.srcObject에 할당하여 Peer B의 비디오를 해당 비디오 엘리먼트에 표시한다. 
    (*) 번외로, roomName은 특정 웹RTC 통화 세션 또는 방을 식별하기 위해 사용되며, 서버는 어떤 참가자들이 같은 통화에 속하는지 알고, 서로 ICE 후보자를 교환한다. 

6. `createOffer`와 `createAnswer`

    ```tsx
      const createOffer = async () => {
        console.log("create Offer");
        if (!(peerRef.current && socketRef.current)) {
          return;
        }
        try {
          const sdp = await peerRef.current.createOffer();
          peerRef.current.setLocalDescription(sdp);
          console.log("sent the offer");
          socketRef.current.emit("offer", sdp, roomName);
        } catch (e) {
          console.error(e);
        }
      };

      const createAnswer = async (sdp: RTCSessionDescription) => {
        console.log("createAnswer");
        if (!(peerRef.current && socketRef.current)) {
          return;
        }

        try {
          peerRef.current.setRemoteDescription(sdp);
          const answerSdp = await peerRef.current.createAnswer();
          peerRef.current.setLocalDescription(answerSdp);

          console.log("sent the answer");
          socketRef.current.emit("answer", answerSdp, roomName);
        } catch (e) {
          console.error(e);
        }
      };
    ```

    #### createOffer 함수
    - `createOffer`는 로컬피어(new RTCPeerConnection)에서 offer를 생성하고 서버로 보내는 역할을 한다. 
    - `setLocalDescription` : 코드는 유효성검사를 수행 뒤에 WebRTC의 setLocalDescription 메소드를 실행시키는데, 이는 피어 연결의 로컬 세션 설명을 설정하는 데 사용된다. 세션 설명은 미디어 트랙(오디오 및 비디오), 코덱, ICE 후보자 및 기타 상세 정보를 포함한다. 
    - `emit("answer", answerSdp, roomName)` 그 결과를 서버로 보내는 것이다. 여기서 전제가 되는 것은 ICE 후보자를 보냈던 이전 내용이 성사되었기 때문임이 배경이다.(peerRef.current.onicecandidate)

    #### createAnswer 함수
    - `createAnswer` 함수는 수신한 Offer에 대한 Answer를 생성하고 서버로 보내는 역할을 한다.
    - `setRemoteDescription`는 매개변수로 받은 (sdp: RTCSessionDescription)를 호출하여 수신한 Offer (sdp)를 로컬 피어의 원격 설명으로 설정합니다. 이로써 로컬 피어는 Peer B의 연결 정보를 받게 되는 것이다. 이후 emit("answer", answerSdp, roomName)를 통해 서버로 Answer (answerSdp)와 roomName을 보내고, 서버는 이 정보를 Peer A에게 전달함으로 연결을 구현한다. 

    #### Offer-Answer
     Peer A가 createOffer를 통해 Offer를 생성하고 서버에 보내면, 서버는 Offer를 Peer B에게 전달합니다. 그리고 Peer B는 createAnswer를 통해 수신한 Offer에 대한 Answer를 생성하여 서버에 보냅니다. 이를 통해 두 피어는 서로의 연결 정보를 교환하고, WebRTC를 사용하여 실시간 통신을 수행할 준비를 마치게 됩니다.


</details>

<details>
<summary>WebRTC란? (2) 이론적인 정리, 위의 내용 가다듬기</summary>

위의 내용이 길어지기에, 잠시 멈추고 개념을 확실하게 정리한 후에 넘어가고자 한다. 4가지를 주제로 내용을 정리하고자 한다. 

1. 사용자로부터 영상받아오기 
<img src="../img/webRTC.gif">

    - `navigator.mediaDevices.getUserMedia`만 있으면, 사용자로부터 영상 정보를 받아올 수 있다. 이후, 해당 내용을 Ref를 통해서 참조하고 있는 video 태그에 전달해주면 된다. 단지 이것으로 화면에 영상을 띄울 수 있다. 

    ```tsx
    import React, { useEffect, useRef } from 'react'

    export const WebRTC: React.FC = () => {
      const MyVideoRef = useRef<HTMLVideoElement>(null) // DOM

      const getMedia = async () => {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: true, // audio: true,        
          });

          if (MyVideoRef.current) {
            MyVideoRef.current.srcObject = stream
          }
        } catch (e) {
          console.error(e);
        }
      }

      useEffect(() => {
        getMedia()
      }, [])

      return (
        <div>
          <h1>WebRTC</h1>
          <video ref={MyVideoRef} style={{
            width: 1000,
            height: 800,
            backgroundColor: "black",
            transform: "scaleX(-1)"
          }}
            autoPlay />
        </div>
      )
    }
    ```

2. ICE 후보자 

    - ICE (Interactive Connectivity Establishment) : WebRTC에서 인터넷 상에서 피어 간 연결을 설정하는데 사용되는 프래임워크이다. ICE는 STUN과 TURN과 같은 기술을 사용하여 피어 간의 최적의 네트워크 경로를 발견하고 협상하는 데 사용된다. ICE 후보자들은 시그널링 채널을 통해 피어들 같에 교환되어, 각 피어가 상대 피어의 잠재적인 네트워크 경로를 알 수 있게 된다. ICE를 사용함으로, WecRTC 애플리케이션은 인터넷 상에서 직접적인 피어 간 통신을 확립하며, 최적의 미디어 전송 경로를 최적화하고 안정적인 실시간 통신 경험을 보장할 수 있게 되는 것이다. 

    - `onicecandidate`와 `socket.emit("candidate",)` : Peer A의 정보를 서버에게 알린다. 

3. Peer A와 Peer B : `createOffer`와 `createAnswer`

    - 서로 다른 피어간의 확인이 이뤄진다. 이를 통해서 `ontrack`을 통해 상대방의 영상 정보를 전달받고, 화면에 송출하여 통신을 하는 것이다 .

</details>

<details>
<summary>WebRTC란? (3) useEffect를 통한 웹소켓 연결과 통신</summary>

```tsx
useEffect(() => {
    socketRef.current = io("localhost:8080");

    peerRef.current = new RTCPeerConnection({
      iceServers: [
        {
          urls: "stun:stun.l.google.com:19302",
        },
      ],
    });
	
    // 기존 유저가 있고, 새로운 유저가 들어왔다면 오퍼생성
    socketRef.current.on("all_users", (allUsers: Array<{ id: string }>) => {
      if (allUsers.length > 0) {
        createOffer();
      }
    });
	
    // offer를 전달받은 PeerB만 해당됩니다
    // offer를 들고 만들어둔 answer 함수 실행
    socketRef.current.on("getOffer", (sdp: RTCSessionDescription) => {
      console.log("recv Offer");
      createAnswer(sdp);
    });
    
    // answer를 전달받을 PeerA만 해당됩니다.
    // answer를 전달받아 PeerA의 RemoteDescription에 등록
    socketRef.current.on("getAnswer", (sdp: RTCSessionDescription) => {
      console.log("recv Answer");
      if (!peerRef.current) {
        return;
      }
      peerRef.current.setRemoteDescription(sdp);
    });
    
    // 서로의 candidate를 전달받아 등록
    socketRef.current.on("getCandidate", async (candidate: RTCIceCandidate) => {
      if (!peerRef.current) {
        return;
      }

      await peerRef.current.addIceCandidate(candidate);
    });
	
    // 마운트시 해당 방의 roomName을 서버에 전달
    socketRef.current.emit("join_room", {
      room: roomName,
    });

    getMedia();

    return () => {
      // 언마운트시 socket disconnect
      if (socketRef.current) {
        socketRef.current.disconnect();
      }
      if (peerRef.current) {
        peerRef.current.close();
      }
    };
  }, []);
```

  - `peerRef.current.addIceCandidate`를 통해서 서버로부터 전달받은 PeerB 정보를 전달받고 이를 `RTCPeerConnection` 객체에 추가한다. 
  - 위의 코드에서 `socketRef.current.emit("offer", sdp, roomName)`로 전달된 정보는 상대 Peer에게로 `socketRef.current.on("getAnswer", (sdp: RTCSessionDescription) => {})`로 전달된다. 

  - 이렇게 하여 두 클라이언트는 서로의 오퍼-앤서 과정을 거쳐 영상 및 오디오 데이터를 교환하여 실시간 통신을 구현한다. 
</details>

<details>
<summary>WebRTC, Socket의 두 클라이언트를 동적으로 JOIN 해주기</summary>

방을 JOIN을 생성하는 방법은 3가지 정도의 방법이 있을 것 같다. 
1. 사용자가 직접 방 이름을 입력하도록 유도하는 방법 : 사용자가 접속하려는 방이름을 입력하도록 유도하여, 두 사용자가 동일한 방 이름을 입력하면 같은 방에 접속하도록 하는 방법이다. 

2. 서버가 미리 정해둔 방 이름을 전달하는 방법 : 서버가 미리 정해둔 방 이름을 클라이언트에게 전달하여, 두 사용자가 받은 방 이름을 사용하여 같은 방에 접속하도록 하는 방법이다. 

3. 방 목록을 제공하고 사용자가 선택하도록 하는 방법 : 서버가 현재 연린 방 목록을 클라이언트에게 제공하고, 사용자가 방을 선택하여 접속하도록 한다. 



- https://hohoya33.tistory.com/203
</details>


<details>
<summary>리액트 ENV(환경변수), Github </summary>
<img src="../img/github-secrets(1).png">

리액트를 개발할 때, 기억할 한 가지는 은닉해야 하는 민감한 정보들에 대한 관심이다. 그래서 가장 먼저 하는 일은 `.env` 파일을 만드는 일과 이를 git 시스템에서 배제하는 작업이다. 

그러나 이 과정에서도 한계는 있다. 바로, 파일이 빌드될 때 포함된다는 말이다. 그렇다면 이러한 민감한 정보들에 대해서 어떻게 관리를 할 수 있을까라는 주제 역시도 개발자는 고민을 해야 된다. 

```bash
# 먼저 env 파일을 개발시로 한정지어, 빌드파일에 포함되지 않도록 파일을 변경해준다. 
.env.development
```

이후 작업은 사전에 CD를 구축하면서 마련해 놓은, GitHub Actions .yml 파일에서 새로운 환경변수 파일을 생성하는 작업이다. 

```yml
 - name: Setting .env
        run: |
          echo "GENERATE_SOURCEMAP=${{ secrets.GENERATE_SOURCEMAP }}" >> .env
          echo "REACT_APP_SERVER_KEY=${{ secrets.REACT_APP_SERVER_KEY }}" >> .env
          echo "REACT_APP_KAKAO_REST_API=${{ secrets.REACT_APP_KAKAO_REST_API }}" >> .env
          echo "REACT_APP__KAKAO_REDIRECT_URL=${{ secrets.REACT_APP__KAKAO_REDIRECT_URL }}" >> .env
          echo "REACT_APP_GOOGLE_REST_API=${{ secrets.REACT_APP_GOOGLE_REST_API }}" >> .env
          echo "REACT_APP_GOOGLE_REDIRECT_URL=${{ secrets.REACT_APP_GOOGLE_REDIRECT_URL }}" >> .env
          cat .env
```

마지막에 있는 `cat .env`는 생성된 환경변수를 CLI에서 확인할 수 있도록 설정한 부분으로, 누락된 환경변수가 없는지 확인할 수 있는 용도이다. 
</details>

<details>
<summary>스플리쉬 스크린</summary>
<img src="../img/Splash.gif">

웹 개발에서는 많이 사용되지 않을지 모르지만, 사용자가 브라우저에 접근했을 때, 가장 먼저 해당 사이트를 인지할 수 있도록 어떤 스크린을 보여주는 것 바로 그것이 스플리쉬 스크린이다. 

이를 위해서 여러 이미지가 있겠으나, JSON 파일을 만들어서 이번에는 작업을 진행했다. 이 과정에서 사용된 라이브러리가 있는데 다음과 같다. 

```bash 
yarn add react-lottie
yarn add --dev @types/react-lottie
```

`react-lottie` 라이브러리는 이번 과정에서 처음 사용하게 된 라이브러리이다. [공식사이트](https://lottiefiles.com)의 설명에 따르면 `lottie`는 안드로이드, IOS, 웹 브라우저, 리액트 등과 호환되는 고품질 JSON 인코딩 애니메이션을 제공한다. 

```tsx
import React from 'react'
import Lottie from 'react-lottie';
import LottieData from './300_logo.json'
import { useMainHeader } from '../../hooks'

export const Splash:React.FC = () => {
  const { SplashScreenRef } = useMainHeader()
  const defaultOptions = {
    loop: false,
    autoplay: true,
    animationData: LottieData,
    rendererSettings: {
      preserveAspectRatio: 'xMidYMid slice',
    },
  };

  return (
    <SC.SplashScreen ref={SplashScreenRef}>

      <Lottie
        options={defaultOptions}
        height={300}
        width={300}
        isClickToPauseDisabled={false}
      />
  </SC.SplashScreen>
  )
}
```

사용법은 위와 같다. `LottieData`에 해당되는 json 파일을 컴포넌트에 불러온다. 이후에는 `defaultOptions`을 설정해주고, 라이브러리에서 제공하는 `Lottie`에 해당 파일을 밀어넣어주면 된다. 

- loop: false, 반복여부 설정
- autoplay: true, 자동실행 
- isClickToPauseDisabled, 클릭에 따른 동작제어

</details >


<details>
<summary>전역상태 관리와 리액트의 리렌더링 제어</summary>

리액트를 제어한다는 것은 리렌더링 시점을 개발자의 의도대로 이끌어간다는 부분이다. 리렌더링은 비용과 관련 있기에 불필요한 리렌더링을 방지하는 애플리케이션의 성능향상과도 밀접하게 연결되어 있다. 

1. 아마도 가장 쉽게 접근할 수 있는 Form 태그

    Form 에는 여러 개의 input이 존재한다. 이때 모든 inputs의 state를 하나의 useState로 관리하곤 했는데, 이러한 방법은 리렌더링에서 inputs 전부의 리렌더링을 초래한다는 부분애서 좋은 접근은 아니었다. 이를 개선하기 위해새서 useState와 input을 atom화 하여 코드를 불리시켰다.

    ```tsx
    const SignUpInput: React.FC<{ placeholder: string; name: string }> = ({
      placeholder,
      name,
    }) => {
      const [input, setInput] = useState<string>("");
      const onChangeInput = (e: ChangeEvent<HTMLInputElement>) => {
        setInput(e.target.value);
      };

      return (
        <SC.AuthInput
          type="text"
          value={input}
          onChange={onChangeInput}
          placeholder={placeholder}
        />
      );
    };
    ```

    이로서 inputs 각각의 연결고리를 끊어놓았기 때문에 하나의 input에 대해서 다른 inputs가 영향받지 않도록 구성했다. 

2. Form 태그에서 해당 inputs 들의 값을 서버로 전송하기     

    ```tsx
    export const Signup: React.FC = () => {
      const onSubmitSign = (e: FormEvent<HTMLFormElement>) => {
        e.preventDefault();
        console.log(SignupData); // ??
      };

      return (
        <Form onSubmit={onSubmitSign} $fd="column" $gap={20}>
          <SignUpInput name="email" placeholder="이메일 형식으로 입력해주세요." />
          <SignUpInput name="nickname" placeholder="이름을 입력해 주세요." />
          <SignUpInput name="password" placeholder="비밀번호를 입력해 주세요." />
          <SignUpInput
            name="pwChecked"
            placeholder="비밀번호를 다시 입력해 주세요."
          />
          <SignUpInput name="phonNumber" placeholder="휴대전화를 입력해주세요." />
          <input type="submit" value="제출" />
        </Form>
      );
    };
    ```

    질문은 어떻게 하위에 있는 state를 상위로 끌어올릴 것인가, 그것도 리렌더링 발생없이 말이다. 리렌더링 때문에 상태를 전부 하위 컴포넌트로 내려주었는데 말이다. 바로 이때 구축해 놓은 `Redux`를 활용한 전역 상태 관리 시스켐이다. 

    ```tsx
    import { PayloadAction, createSlice } from "@reduxjs/toolkit";

    const SignupSlice = createSlice({
      name: "SignupSlice",
      initialState: {} as any | {},
      reducers: {
        setSignupDate: (state, action: PayloadAction<any>) => {
          return { ...state, ...action.payload };
        },
      },
    });

    export const SignupReducer = SignupSlice.reducer;
    export const selectSignup = (state: any) => state.SignupReducer;
    export const { setSignupDate } = SignupSlice.actions;
    ```

    일단은 테스크를 위해서 state의 상태를 any로 설정했지만, 추후에 해당 타입을 정확하게 잡을 것이다. 이와 같이 초기값이 빈객체인 슬라이스를 입력될 때마다 추가해주면 되지 않겠느냐는 야이이어였다. 이후 submit 시에 해당 로직을 초기화 해주면 될 것이다. 

    ```tsx
    const SignUpInput: React.FC<{ placeholder: string; name: string }> = ({
      placeholder,
      name,
    }) => {
      const [input, setInput] = useState<string>("");
      const onChangeInput = (e: ChangeEvent<HTMLInputElement>) => {
        setInput(e.target.value);
      };

      const disptach = RTK.useAppDispatch();
      const onBlurSignupDispatch = () => {
        name !== "pwChecked" && disptach(RTK.setSignupDate({ [`${name}`]: input }));
      };

      return (
        <SC.AuthInput
          type="text"
          value={input}
          onBlur={onBlurSignupDispatch}
          onChange={onChangeInput}
          placeholder={placeholder}
        />
      );
    };
    ```

    SignUpInput 컴포넌트로 돌아와서, 이제 해당 dispatsh를 실행시켜주면 되는데 언제 실행시킬지에 대한 고민이 또 발생한다. 이를 위해서 `onBlur` 이벤트, 즉 해당 태그가 포커스를 상실할 때 요청이 이뤄지도록 설정했다. 그러나 해당 부분이 동적으로 동작해야 된다는 측면에서 해당 태그에 name을 설정하고, 해당 네임에 따라서 dispatsh가 실행되게 하였다. 이때, 필요가 없는 pwChecked는 포함시키지 않았다. 

    ```tsx
    // Form 컴포넌트
    const getSignup = RTK.useAppSelector(RTK.selectSignup);
    // 리덕스의 값을 호출하고 
    const onSubmitSign = (e: FormEvent<HTMLFormElement>) => {
      e.preventDefault();
      console.log(getSignup);
    };
    // 해당 내용을 처리하면 로직은 완성된다. 
    ```

    이러한 식으로 리렌더린의 연결고리를 끊어냈지만, 그럼에도 데이터를 활용할 수 있는 방안인 전역상태 관리에 대해서 한 단계더 깊은 고민을 할 수 있게 되는 시간이었다. 
</details >