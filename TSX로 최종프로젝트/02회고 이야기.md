## 이노캠모터스 회고노트

### 첫번째 이야기 
7월 21일 첫 만남으로 시작하여, 프로젝트를 진행한지 4일이 지났다. 6주라는 짧은 시간이지만, 틈틈히 회고를 남기지 않으면 공부한 기억들이 사장될 위험이 있기에, 이렇게 저금씩 공부했고, 고민했던 흔적들을 남기고자 한다. 

<details>
<summary>타입스크립트와 라이브러리, 맛보기</summary>
<br/>
가장 먼저 이야기할 부분은 `타입스크립트`에 대한 부분이었다. 이론으로 타입을 선언하는 부분에 대해서 공부했지만, 실전은 달랐다. 모든 것에 타입을 지정해주어야 했기 때문이다. 라이브러리에도 타입이 존재했으며, 해당 타입을 설정해주지 않으면 컴파일 단계에서 에러가 발생되어 아무것도 할 수 없는 상황이 되었다. 4일 동안의 짧은 기간이었지만, 그 동안의 짧은 이야기라도 기록으로 남겨, 훗날의 이를 회상하는데 도움을 주고자 한다. 

1. Axios 라이브러리의 타입적용

    리액트 JS에서는 고민없이 사용했던 라이브러리에도 타입설정이 필요했다. `인스턴스`를 생성하는 부분에도 타입설정이 필요했고, `인터셉터`를 적용하는 부분에서도 `config`와 `response`에 따라서 타입을 지정해 줘야 했다. 또한 번외의 이야기지만, `config`와 `response`를 인터셉터해서 어떤 처리를 하면, 반드시 두 요소를 return 해주어야 결과값을 전달하고 전달받는 다는 것 또한 유념해야할 이이었다. 

    ```tsx
    import axios, * as axiosType from 'axios';

    // axios 인스턴스 생성
    export const instance: axiosType.AxiosInstance = axios.create({
    baseURL: process.env.REACT_APP_SERVER_KEY,
    });

    interface MyAxiosRequestConfig extends axiosType.AxiosRequestConfig {
    headers: axiosType.AxiosRequestHeaders;
    }

    // 요청 인터셉터 설정
    instance.interceptors.request.use(
    (config: MyAxiosRequestConfig) => {
        ...
        return config;
    },
    (error) => {
        return Promise.reject(error);
    },
    );

    // 응답 인터셉터 설정
    instance.interceptors.response.use(
    (response: axiosType.AxiosResponse) => {
        ...
        return response;
    },
    (error) => {
        return Promise.reject(error);
    },
    );
    ```

2. RTK-query 라이브러리의 타입적용

    이번 4일의 작업에서 타입설정과 관련하여 가장 어려웠던 부분은 `RTK-query` 부분의 타입을 설정하는 일이었다. 특별히 `catch(error)` 부분의 타입을 지정해 주는 부분이 특별히 기억에 남는다. 반나절 정도를 찾아보고 내용을 적용시켰던 것 같다. 공식문서를 열심히 살펴보았지만, 익숙하지 않아서 어려움이 있었다. 그러나 이 과정에서 이미 라이브러리를 제공해주는 곳에서 만들어진 `index.d.ts`를 잘 살펴보는 것만으로 문제를 쉽게 접근할 수 있다는 것을 배우게 되었다. 

    ```tsx
    export const inocamRTK = createApi({
        baseQuery: axiosBaseQuery(),
        tagTypes: ['POSTS', 'POSTDETAIL', 'POSTCOMMENT'],
        endpoints(build) {}
    })
    ```

    (1) RTK-query에서 설정할 타입은 `axiosBaseQuery`부분으로 아래와 같다. 

    (2) `BaseQueryFn`를 설정함에 있어서, 개발자가 지정하고 싶은 내용을 추가로 기록할 수 있는데, 매번 포함되지 않는 요소에는 옵셔널체이닝(?)을 설정해 주었고, method와 data는 기본적으로 제공되어 있는 타입선언을 활용하면 된다. 

    ```tsx
    const axiosBaseQuery = (): BaseQueryFn<{
        url: string;
        method: AxiosRequestConfig['method']
        data?: AxiosRequestConfig['data'];
        types?: string;
    }> => async ({ url, method, data, types }) => {}
    ```

    (3) `catch (axiosError)`에 있어서의 에러타입설정 부분이 특히 어려웠다. 

    ```tsx
    catch (axiosError) {
        const err = axiosError as Type.CustomAxiosError<Type.ErrorType['data']>; // 타입단언
        return {
          error: err.response?.data.msg
        };
    }

    // responseType.d.ts
    export interface ErrorType {
        data: {
            error: boolean,
            status:number,
            msg: string
        }
    }
    export interface CustomAxiosError<T> extends AxiosError {
        response?: AxiosResponse<T>
    }
    ```

    타입가드도 생각해봤지만, 결국은 `타입단언`을 통해서 적용했다. 기존에 있었던 `AxiosError`를 상속받아서, `AxiosResponse`를 더하고, 여기에 `제네릭`을 설정했다. 그리고 이를 활용하는 부분에서 `ErrorType`를 넣어서 작업했다. 
</details>



<details>
<summary>타입스크립트와 타입선언</summary>
<br/>

타입선언은 `type`과 `interface` 두 가지 방법이 있고, 두 가지 방법은 각각의 목적과 사용 방법의 차이가 있다. 

1. `type` 알리아스(타입별칭)

    `type`은 기존 타임에 별칭을 붙여서 재사용하기 쉬운 커스텀 타입을 만들 때 유용한다. 타입의 확장은 아래와 같이 가능하다. 

    ```tsx
    type Person = {
        name: string;
        age: number;
    };

    type MyIntersection = Person & { email: string };
    ```

2. `interface` 객체의 구조를 정의한다. 

    주로 객체 간의 상호 작용을 명시적으로 지정하거나, 클래스가 구현해야 하는 메서드와 속성을 정의하는데 사용한다. 결국에는 성향차이라고 하는데, 일반적으로 별칭은 간단하고 범용적인 타입 선언에 적합하며, 인터페이스는 객체 간의 상호 작용과 클래스 구현에 더 적합한 것으로 구분하여 사용한다. 아래는 이번 프로젝트에서 사용한 `interface` 정의 목록이다. 범용적으로 사용하기 위해 타입을 구분했고, 각각의 상황에 따라서 사용할 수 있도록, export 해주었다. 

    ```tsx
    export interface CommentsData {
        comment_id: number;
        nickname: string;
        comment: string;
        created_at: string;
        modified_at: string;
    }

    export interface PostPosts {
        title:string;
        content:string;
        post_id?: number;
    }

    export interface PostsData extends PostPosts {
        is_like: boolean;
        like_count: number;
        comment_count?: number;
    }

    export interface PostsDetailData extends PostsData {
        image_urls: string[];
        comment: CommentsData[];
    }   
    ```

3. 컴포넌트의 props에 대한 타입지정

    ```tsx
     return (<EditCommunityDetail post_id={post_id} title={title} content={content} />)

     export const EditCommunityDetail: React.FC<Type.PostPosts> = ({ post_id, title, content }) => {

        return <div>로그인 ...</div>
     }
    ```
</details>


<details>
<summary>상태관리와 RTK-query, MSW</summary>
<br/>

상태관리는 언제나 어려운 주제이다. Redux, ContextAPI, 그리고 Recoil 등이 큰 축인 것 같다. 그리고 네트워크 통신과 관련해서는 RTK-createAysnsThunk, React-query, RTK-query 등으로 접근이 가능할 것이다. 

먼저, RTK-createAysnsThunk는 리덕스를 기반으로 확장되었다는 점에서 장점이 있다. 하지만, isLoading, isError 등의 상황을 모두 직접 기록해야 한다는 점과, 저장 위치가 메인 메모리에 저장된다는 점에서 다소 불편함이 있다. 

React-query는 네트워크 전용 상태관리를 표망하며, 비동기 통신 전용의 상태관리 라이브러리이다. 데이터를 캐시에 저장하여 효율적으로 데이터를 캐싱하고 패싱한다. 그러나 로직이 분산되어 있다는 한계는 있다. 

이번 프로젝트에서 채택한 RTK-query는 리덕스가 가진 중앙집중화의 장점을 가지고 API를 구현한다. 또한, 데이터를 React-query 처럼 캐시에 저장하여 효율적으로 데이터를 관리한다. 

이번 프로젝트에서는 axios + RTK-query + MSW를 통한 테스트 서버를 구현하여 빠르게 개발을 진행하도록 시도하였다. 

```tsx
export const inocamRTK = createApi({
  baseQuery: axiosBaseQuery(),
  tagTypes: ['POSTS', 'POSTDETAIL', 'POSTCOMMENT'],
  endpoints(build) {
    return {
      // loginRTK
      postLogin: build.mutation({
        query: (data) => ({
          url: '/api/auth/login',
          method: 'post',
          data,
          types: 'login',
        }),
      }),
      // Signup
      postSignup: build.mutation({
        query: (data) => ({
          url: '/api/auth/signup',
          method: 'post',
          data,
          types: 'signup',
        }),
      }),
      // getEmailCheck
      getEmailCheck: build.query({
        query: (email) => ({
          url: `/api/auth/email?email=${email}`,
          method: 'get',
          types: 'getCheck',
        }),
      }),
      // getNickNameCheck
      getNickCheck: build.query({
        query: (nickname) => ({
          url: `/api/auth/nickname?nickname=${nickname}`,
          method: 'get',
          types: 'getCheck',
        }),
      }),

      // getPosts - 차량출고 커뮤니티
      getPosts: build.query({
        query: () => ({
          url: `/api/posts`,
          method: 'get',
          types: 'getData',
        }),
        providesTags: ['POSTS']
      }),

      // postPosts - 차량출고 커뮤니티
      postPosts: build.mutation({
        query: (data) => ({
          url: `/api/posts`,
          method: 'post',
          data,
          types: 'multipart',
        }),
        invalidatesTags: ['POSTS']
      }),

      // DeletePosts - 차량출고 커뮤니티 게시글 삭제
      DeletePosts: build.mutation({
        query: (postId) => ({
          url: `/api/posts/${postId}`,
          method: 'delete',
        }),
        invalidatesTags: ['POSTS']
      }),

      // EditPosts - 차량출고 커뮤니티 게시글 수정
      patchPosts: build.mutation({
        query: ({postId, formData}) => ({
        url: `/api/posts/${postId}`,
        method: 'patch',
        data:formData,
        types:'multipart'
      }),
      invalidatesTags: ['POSTS', "POSTDETAIL"]
      }),


      // getPostsDetail - 차량출고 커뮤니티 게시글
      getPostsDetail: build.query({
        query: (postId) => ({
          url: `/api/posts/${postId}`,
          method: 'get',
          types: 'getData',
        }),
        providesTags: ['POSTDETAIL']
      }),

      // postComment - 차량출고 커뮤니티 댓글작성
      postComment: build.mutation({
        query: ({postId, data}) => ({
          url: `/api/posts/${postId}/comments`,
          method: 'post',
          data
        }),
        invalidatesTags: ['POSTDETAIL']
      }),


    };
  },
});

export const {
  // Auth
  usePostLoginMutation,
  usePostSignupMutation,
  useGetEmailCheckQuery,
  useGetNickCheckQuery,

  // Posts 차량출고 커뮤니티 관련
  useGetPostsQuery,
  usePostPostsMutation,
  useDeletePostsMutation,
  usePatchPostsMutation,
  useGetPostsDetailQuery,
  usePostCommentMutation,
} = inocamRTK;
```

중앙집중화 되어 있다는 점에서 `하나의 API`를 생성하는데 단 몇 분밖에 걸리지 않고, 쉽고 간편하게 useOOOQuery, useOOOMutation을 통해 호출하여 사용할 수 있다. 나아가 get 요청의 경우 조건부로 할 수 있을까 고민을 하게 되었다. 이전 프로젝트에서 React-query 를 했을 때, 사용했던 기억이 있는데 RTK-query도 간편하게 사용할 수 있었다. 

```tsx
 const { 
    isSuccess: checkEmailSuccess, 
    data: checkEmailData, 
    isError: checkEmailError, 
    error: emailError } = useGetEmailCheckQuery(signInfo.email, {skip: checkEmail})
```

`skip`에 들어가는 상태에 따라서 get요청을 제어할 수 있다. `true`를 하면 get요청이 무시된다. 이를 `false`로 변경될 때 요청이 시작된다. 이를 통해서 이메일체크와 닉네임체크 부분을 원하는 호출시점에 제어함으로 개발목적과 의도에 따라 동작하게 하였다. 

```tsx
  const onChangeInput = (e: ChangeEvent<HTMLInputElement>): void => {
    const { name, value } = e.target
    setSignInfo({ ...signInfo, [name]: value })
    setCheckEmail(true)
    setCheckNickName(true)
  }  
```

나아가 새로운 입력에 대한 이벤트가 발생되었을 때에는 이를 다시 true 로 번경하여 호출되지 않도록 제한하였다. 

### 이번에는 MSW이다. 

MSw는 정말 막강하다. API 배포와 디자인 가이드가 나오지 않는 시점에서 빠르게 코드를 테스르 하여, 서버통신을 가정한 상태로 개발을 진행할 수 있었고 그 결과는 대단했다. 다음은 이제 스타일드 컴포넌트를 모듈화하면 될 것 같다. 이후는 이제 생성한 모듈을 실제로 그리는 일만 남았다. 

```tsx
import { rest } from 'msw';
import * as TestDB from './testData';
import * as Type from '../types';


export const handlers = [
  // Login
  rest.post<Type.User>(`${process.env.REACT_APP_SERVER_KEY}/api/auth/login`,
    async (req, res, ctx) => {
      const request = req.body;
      const find = TestDB.logindata.find(user => user.email === request.email)

      if (find && request.password === find.password) {
        return res(
          ctx.status(200),
          ctx.json({
            success: true,
            status: 200,
            msg: '로그인성공',
          }),
          ctx.set(
            'authorization',
            'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5',
          ),
        );
        // 배열에서 존재하지 않으면...   
      } else if (find && request.password !== find.password) {
        return res(
          ctx.status(401), // 인증되지 않음
          ctx.json({
            error: true,
            status: 401,
            msg: '비밀번호가 틀렸습니다.',
          }),
        );
        // 배열은 있는데 비밀번호가 틀린 경우
      } else {
        return res(
          ctx.status(401), // 인증되지 않음(리소스에 없음) 
          ctx.json({
            error: true,
            status: 401,
            msg: '존재하지 않는 이메일 입니다.',
          }),
        );
      }
    },
  ),

  // Signup
  rest.post<Type.UserInfo>(`${process.env.REACT_APP_SERVER_KEY}/api/auth/signup`,
    async (req, res, ctx) => {
      const request = req.body;
      TestDB.logindata.push(request)
      return res(
        ctx.status(200),
        ctx.json({
          success: true,
          status: 200,
          msg: '회원가입성공',
        }),
      );
    }
  ),

  // Signup-emailCheck
  rest.get<Type.UserInfo>(`${process.env.REACT_APP_SERVER_KEY}/api/auth/email`,
    async (req, res, ctx) => {
      const checkEmail = req.url.searchParams.get('email')
      const find = TestDB.logindata.find(user => user.email === checkEmail) || null
      if (!find) {
        return res(
          ctx.status(200),
          ctx.json({
            success: true,
            status: 200,
            msg: '사용 가능한 이메일 입니다.'
          }),
        );
      } else {
        return res(
          ctx.status(409), // 이미 리소스 상에 존재하면
          ctx.json({
            error: true,
            status: 409,
            msg: '이미 존재하는 이메일 입니다.',
          }),
        );
      }
    }
  ),

  // Signup-NickNameCheck
  rest.get<Type.UserInfo>(`${process.env.REACT_APP_SERVER_KEY}/api/auth/nickname`,
    async (req, res, ctx) => {
      const checkNickName = req.url.searchParams.get('nickname')
      const find = TestDB.logindata.find(user => user.nickname === checkNickName) || null
      if (!find) {
        return res(
          ctx.status(200),
          ctx.json({
            success: true,
            status: 200,
            msg: '사용 가능한 닉네임 입니다.'
          }),
        );
      } else {
        return res(
          ctx.status(409), // 이미 리소스 상에 존재하면
          ctx.json({
            error: true,
            status: 409,
            msg: '이미 존재하는 닉네임 입니다.',
          }),
        );
      }
    }
  ),

  // getPosts - 차량출고 커뮤니티 
  rest.get(`${process.env.REACT_APP_SERVER_KEY}/api/posts`,
    async (_, res, ctx) => {
      return res(
        ctx.status(200),
        ctx.json({
          success: true,
          status: 200,
          msg: '게시글이 조회되었습니다.',
          data: TestDB.postdata
        }),
      );
    }
  ),

  // getPosts - 차량출고 커뮤니티 게시글 조회 
  rest.get(`${process.env.REACT_APP_SERVER_KEY}/api/posts/`, // ${postId}
    async (_, res, ctx) => {
      return res(
        ctx.status(200),
        ctx.json({
          success: true,
          status: 200,
          msg: '게시글이 조회되었습니다.',
          data: TestDB.postdata
        }),
      );
    }
  ),

  // getPostDeatil - 차량출고 커뮤니티 게시글 조회 
  rest.get(`${process.env.REACT_APP_SERVER_KEY}/api/posts/:id`,
    async (req, res, ctx) => {
      const find = TestDB.postDetailData.find(post => post.post_id === +req.params.id)
      return res(
        ctx.status(200),
        ctx.json({
          success: true,
          status: 200,
          msg: '게시글이 조회되었습니다.',
          data: [find]
        }),
      );
    }
  ),

  // postPosts - 차량출고 커뮤니티 
  rest.post(`${process.env.REACT_APP_SERVER_KEY}/api/posts`,
    async (_, res, ctx) => {
      return res(
        ctx.status(200),
        ctx.json({
          success: true,
          status: 200,
          msg: '게시글이 등록이 등록되었습니다.'
        }),
      );
    }
  ),

  // deletePosts - 차량출고 커뮤니티 게시글 삭제
  rest.delete(`${process.env.REACT_APP_SERVER_KEY}/api/posts/:id`,
    async (req, res, ctx) => {
      const findIndex = TestDB.postdata.findIndex((post: Type.PostsData) => post.post_id === +req.params.id)
      TestDB.postdata.splice(findIndex, 1)

      return res(
        ctx.status(200),
        ctx.json({
          success: true,
          status: 200,
          msg: '게시글이 삭제되었습니다.'
        }),
      );
    }
  ),

// patchPosts - 차량출고 커뮤니티 게시글 수정
rest.patch(`${process.env.REACT_APP_SERVER_KEY}/api/posts/:id`,
async (req, res, ctx) => {
  console.log("patchPosts", req);
  return res(
    ctx.status(200),
    ctx.json({
      success: true,
      status: 200,
      msg: '게시글이 수정되었습니다.'
    }),
  );
}
),

// postPostsComment - 차량출고 커뮤니티 게시글 댓글작성
rest.post(`${process.env.REACT_APP_SERVER_KEY}/api/posts/:id/comments`,
async (req, res, ctx) => {
  console.log("patchPosts", req.body);
  return res(
    ctx.status(200),
    ctx.json({
      success: true,
      status: 200,
      msg: '댓글이 입력 되었습니다.'
    }),
  );
}
),

// deletePostsComment - 차량출고 커뮤니티 게시글 댓글작성
rest.delete(`${process.env.REACT_APP_SERVER_KEY}/api/posts/:postid/comments/:commentid`,
async (req, res, ctx) => {
  console.log("deletePostsComment", req.params.id);
  return res(
    ctx.status(200),
    ctx.json({
      success: true,
      status: 200,
      msg: '댓글이 삭제 되었습니다.'
    }),
  );
}
),

// postPostsComment - 차량출고 커뮤니티 게시글 댓글작성
rest.patch(`${process.env.REACT_APP_SERVER_KEY}/api/posts/:postid/comments/:commentid`,
async (req, res, ctx) => {
  console.log("patchPosts", req.params.id, req.body);
  return res(
    ctx.status(200),
    ctx.json({
      success: true,
      status: 200,
      msg: '댓글이 수정 되었습니다.'
    }),
  );
}
),
];
```
</details>

<details>
<summary>타입스크립트와 유틸리티 : Partial</summary>

타입스크립트에는 타입을 조작할 수 있는 유틸리티 타입이 존재한다. 그 가운데 3 가지를 소개하고자 한다. 

1. Partial 타입이다. 

    아래는 실제 프로젝트에서 `스타일드 컴포넌트`의 타입을 설정하며 고민했던 내용의 결과이다. 처음에는 계속해서 `interface`를 생성하고, 그 안에 `옵셔널`로 타입을 정의하려고 했었다. 그 결과 모든 타입정의에 `옵셔녈`이 들어가게 되는 상황이 발생되었고, 과연 이것이 효율적인가 고민하게 되었다. 또한 반복되는 타입들의 중복을 제거하고자 하는 욕심도 있었다. 
    
    중복을 제거하면서, 타입검사를 느슨하게 만드는 옵셔널을 피하면서 타입을 정의하는 방법이 있을까 고민하던 가운데, `Partial`을 찾게 되었다. 유틸리티 타입은 바로 이럴 때 사용되는 것 같다. Partial는 모든 요소를 옵셔널로 지정한 타입으로 만들어낸다. 그러기에, 실제 사용하는 타입선언에서는 필요한 내용만을 꺼내서 사용한다. 

    `옵셔널`로 만든다는 것은 동일한 내용 같은데 무엇이 다를까? 옵셔널로 지정하는 사례는 타입정의를 변경하여 선택적으로 만들어내지만, `Partial`은 새로운 타입을 생성하여 선택적으로 만들어낸다. 즉 이미 존재하는 타입에 대해 선택적인 버전을 생성하기에 기존 타입 정의를 변경하지 않고 유연하게 다룬다는 점이 다르다. 즉  `Partial` 타입은 기존 타입을 복제하여 각 속성을 선택적으로 만들기 때문에 타입 정의를 반복하지 않고도 선택적인 타입을 쉽게 만들 수 있습니다.

    ```tsx
    export interface Styled {
      // commen
      $color:string;
      $width:string;
      $height:string;

      // Felx-Grid
      $gap: number;

      // Flex
      $fd: string;
      $jc: string;
      $ai: string;

      // Grid
      $gtc:string;
      $gtr:string;
      $gar:string;
      $cgap: number;
      $rgap: number;

      // GridMergedSpace
      $mergedgcs: number
      $mergedgce: number
      $mergedgrs: number
      $mergedgre: number
    }
    ```

  이에 대한 GPT의 평가는 아래와 같다. 

  (1) 선택적인 Props : 필요한 속성만을 전달함으로 불필요한 속성을 생략하고 간단한 인터페이스로 컴포넌트를 사용할 수 있다고 한다. 

  (2) 재사용성 :  스타일드 컴포넌트를 사용하는 다른 컴포넌트들에서도 동일한 Styled 인터페이스를 사용할 수 있으며, `Partial<Styled>`을 이용하여 필요한 스타일 속성을 선택적으로 전달할 수 있게된다. 이로 인해 스타일드 컴포넌트를 쉽게 재사용할 수 있다. 

  (3) 타입 안정성 : `Partial<Styled>`는 타입 안정성을 제공한다. 컴파일러가 타입 검사를 수행하여 부적절한 속성을 사용하려는 시돌르 방지하고 잘못된 타입으로 인한 오류를 줄여준다. 

  (4) 코드 가독성 : `Partial<Styled>`을 사용하면 필요한 속성을 명시적으로 선택하여 코드의 가독성이 높아진다. 

  (5) 유지보수성 : 스타일드 컴포넌트의 props를 유연하게 다루면 스타일이 변견되거나 추가되는 경우에도 코드 수정이 간단해진다. 새로운 스타일 속성을 추가하기 위해 인터페이스를 추가하는 대신, 해당 속성을 `Partial<Styled>`에 추가하여 필요한 곳에서 선택적으로 사용할 수 있게 만들기 때문이다. 

  정리하면, `Partial<Styled>`를 사용하녀 스타일드 컴포넌트의 props를 선택적으로 만드는 접근 방식은 코드의 유연성, 재사용성, 가독성 및 유지 보수성을 향상시키는 좋은 방법이다. 

  아래는 실제 스타일드 컴포넌트에서 해당 내용을 적용한 사례이다. 

  ```tsx
  /* About Div styled ---------------------------------------------- */
  const FlexBox = sc.styled.div<Partial<Styled>>`
    ${Flex}
  `;

  const GridBox = sc.styled.div<Partial<Styled>>`
    ${Grid}
    background-color:${({$color}) => $color};
  `

  const GridMergedSpace = sc.styled.div<Partial<Styled>>`
    grid-column-start: ${({$mergedgcs}) => $mergedgcs ? $mergedgcs : "auto"};
    grid-column-end: ${({$mergedgce}) => $mergedgce ? $mergedgce : "auto"}; // span 2;
    grid-row-start: ${({$mergedgrs}) => $mergedgrs ? $mergedgrs : "auto"};
    grid-row-end: ${({$mergedgre}) => $mergedgre ? $mergedgre : "auto"}; // span 3;
  `

  const FigureImg = sc.styled.figure<Partial<Styled>>`
    width: ${({ $width }) => $width};
    img {
      display: block;
      width: 100%;
    }
  `;
  ```
</details>


<details>
<summary>CSS와 그리드</summary>

<img src="../img/정규스크럼(3).gif">

```tsx
const GridBox = sc.styled.div<Partial<Styled>>`
  ${Grid}
  background-color:${({$color}) => $color};
`

const GridMergedSpace = sc.styled.div<Partial<Styled>>`
  grid-column-start: ${({$mergedgcs}) => $mergedgcs ? $mergedgcs : "auto"};
  grid-column-end: ${({$mergedgce}) => $mergedgce ? $mergedgce : "auto"}; // span 2;
  grid-row-start: ${({$mergedgrs}) => $mergedgrs ? $mergedgrs : "auto"};
  grid-row-end: ${({$mergedgre}) => $mergedgre ? $mergedgre : "auto"}; // span 3;
`
```

이번 프로젝트를 진행하며, CSS-display-grid에 대한 이해를 보다 높이는 시간이 되었다. 레이아웃 구성에 있어서 그리드는 단연 최고의 속성인 것 같다. 그리드를 연습하며 (1) 레이아웃에 `GridBox`를 선언했고, (2) 내부를 제어하기 위해서 `GridMergedSpace`를 통해서 행과 열의 시작점과 끝점을 설정하여 위치를 조절해 주었다. 

아래의 코드는 위의 그리드 박스를 제어한 컴포넌트의 코드이다. 

- $mergedgcs={2} 
- $mergedgce={5} 
- $mergedgrs={4} 

FE팀에서 설정한 `$mergedgcs`, `$mergedgce`, `$mergedgrs`, `$mergedgre`의 값에 따라서 그리드 내부의 요소의 위치를 조절하여 원하는 위치에 원하는 크기로 설정하게 하였다. 

그리드박스 안에있는 요소들의 각 너비와 높이는 FE팀에서 설정한 속성에 따라서 `<GridBox $gtc="repeat(auto-fill, minmax(25%, auto))" $gar="minmax(200px, auto)">`와 같이 지정해 줌으로 최소값을 지정해 주었다. 

```tsx
import React from 'react';
import { styled } from 'styled-components';
import { FlexBox, GridBox, GridMergedSpaceFlex } from '../../components';

export const DecorationDetail: React.FC = () => {
  return (
    <GridBox $gtc="repeat(auto-fill, minmax(25%, auto))" $gar="minmax(200px, auto)">
      <GridMergedSpaceFlex $mergedgcs={2} $mergedgce={5} $mergedgrs={4} style={{ backgroundColor: "red" }}>나요 </GridMergedSpaceFlex>
      <FlexBox style={{ backgroundColor: "lightcoral" }}>아</FlexBox>
      <FlexBox style={{ backgroundColor: "lightcoral" }}>아</FlexBox>
      <FlexBox style={{ backgroundColor: "lightcoral" }}>아</FlexBox>
      <FlexBox style={{ backgroundColor: "lightcoral" }}>아</FlexBox>
      <FlexBox style={{ backgroundColor: "lightcoral" }}>아</FlexBox>
      <FlexBox style={{ backgroundColor: "lightcoral" }}>아</FlexBox>
      <FlexBox style={{ backgroundColor: "lightcoral" }}>아</FlexBox>
      <FlexBox style={{ backgroundColor: "lightcoral" }}>아</FlexBox>
      <FlexBox style={{ backgroundColor: "lightcoral" }}>아</FlexBox>
      <FlexBox style={{ backgroundColor: "lightcoral" }}>아</FlexBox>
      <FlexBox style={{ backgroundColor: "lightcoral" }}>아</FlexBox>
      <FlexBox style={{ backgroundColor: "lightcoral" }}>아</FlexBox>
      <FlexBox style={{ backgroundColor: "lightcoral" }}>아</FlexBox>

    </GridBox>
  );
};
```

</details>


<details>
<summary>프로그레시브 웹앱 : PWA</summary>

배경은 웹 vs 앱이라는 진부한 싸움을 종료하고, 웹의 장점은 그대로 유지하면서 네이트브 앱의 강점으로 무장한 네이티브 앱의 강력한 기능성과 웹의 뛰어난 접근성을 모두 갖춘 가징 이상적인 형태의 웹앱이라는 개념을 2015sus 구글 크롬 엔지니어인 알렉스 러설이 고안한 개념이다. 

- Y축 : 사용자경험(앱)
- X축 : 접근성(웹)
- 둘다를 충족하는 개념으로서의 PWA : 네이트브 앱 + 모바일 웹뱁 + 하이브리드앱의 강점을 포함하는 앱

본질은 웹이지만, 앱처럼 사용할 수 있어야 한다는 것이다. 목표는 네이티브 앱과 같은 사용자 경험을 제공하는 것이다. 앱을 향해 나아가고 있다는 `철학적 관점에서 progressive` 라고 한다. 

|구분|장점|단점|
|:--|:--|:--|
|개발|이미 익숙한 웹 기술을 그대로 이용할 수 었다. HTML,CSS, JS -> 푸시알림, 오프라인 캐시 등|하드웨어 사용은 웹 API를 통하므로, 웹 표준을 지원하는 브라우저가 필요|
|배포|웹 브라우저만 있으면 어디든 배포할 수 있다, 홈 화면 설치로 OS 응용프로그램으로 설치할 수 있다.|앱스토어, 플레이 스토어를 이용할 수 없다.|
|사용|빠른 실행속도로 네이티브 앱과 유사한 사용자 경험을 제공|안드로이드, 윈도우 OS는 PWA의 모든 기능을 사용할 수 있으나, IOS는 일부로 제한된다.|


1. 프로그레시브 웹앱 : 대표하는 6가지 핵심 기술
- 필수요소 : 서비스 워커, 웹앱 매니페스트, HTTPS
- 중요기능 : 푸시알림, 홈 화면에 추가, 웹API

첫쨰, 서비스 워커 :: `웹 페이지와는 분리되어 항상 실횅되는 백그라운드 프로그램`, PWA의 심장
웹 브라우저는 기본적으로 서버를 통해서 화면을 표시합니다. PWA는 그 사이에서 `서비스 워커`위 위치를 둔다. 그 결과 항상 백그라운드에서 실행되기에, 알림을 받을 수 있게 되는 것이다. 

둘쨰, PWA의 여권 :: `웹앱 매니페스트`, 앱 소개 정보와 기본 설정을 담은 JSON 파일 

셋쨰, 전재는 HTTPS 여야 한다. 


[참고자료, elice](https://elice.io/newsroom/pwa_2)

</details>