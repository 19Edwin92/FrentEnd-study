# 리액트 라우터 돔 
현재 버전은 `v.6.14`이다. 이전 버전과 비교할 때 달라진 부분이 많았다. 해당 라이브러니는 `client side routing`을 구현한다. 전통적인 웹서비스는 SSR을 통해 페이지를 구성했고, 사용자가 새로운 페이지를 요청하면, 그에 대한 새 페이지문서를 다시 내려줘야했었다. 

반면에 CSR을 지원하는 `라우터돔`은 다른 요청이나 다른 문서를 서버에 요청하지 않고, URL을 업데이트하도록 하는 클라이언트 사이드 라우팅을 구현한다. 

다음은 [벨로퍼터](https://velog.io/@velopert/react-router-v6-tutorial)의 내용을 정리한 부분이다. 먼저는 [v5 -> v6](https://www.youtube.com/watch?v=CHHXeHVK-8U)로의 전환을 살펴보자. 

## React Router V5 -> v6
<details>
<summary> 8가지 변경점 살펴보기</summary>

1. Switch => Routes 변경
2. useHistory => useNavigate 변경 : 
    ```javascript 
    const navigate = useNavigate()
    // ...
    navigate("/") // 경로를 설정할 수 있고
    navigate(-1) // 숫자를 넣으면 이전 페이지로 돌아갈 수 있습니다. // 두번 뒤로 가고 싶다. -2 를 하면 됩니다.
    ```
3. useRouterMatch 대신 상대 경로를 사용할 수 있게 되었다. 
    - 그런데 상대 경로를 사용한다는 것은 `useRouterMatch`를 사용할 이유가 없어진 것이다. 
    - Link 를 활용해봅시다. `<Link to="">` 와 같습니다. `<Link to="about">`이라면 현재 경로 뒤에 붙은 `about` 페이지로 이동한다. 
    - 주의할 점은 `<Link to="/about">` 상대경로가 아니라, 절대경로 즉 about 페이지도 이동하게 된다는 것을 기억하자. 
    - `<Route> path="">` 동일합니다. 
4. Route에 children/compoentns 대신 `element`를 통해서 컴포넌트를 입력해야 된다.
    ```Javascript 
    <Route path="/" element={<Home />} />
    ```     

- 또한 우의할 점이 있습니다. `<Route>` 컴포넌트는  `<Routes>` 컴포넌트 안에 있어야 한다.
5. `exact Props` 가 사라짐 : 먼저 v6 이전에 사용되었던 `Exact 속성`에 대해서 알아야 한다. 예를들어 `<Route exact path='/user' component={User} />`에 기록된 `exact`이다. 해당 속성은 경로가 정확히 일치할 때만 해당 라우트가 일치한다고 판단하는 역할을 수행하는 것으로, 주어진 경로와 브라우저의 현재 경로가 정확히 일치해야만 해당 라우트 컴포넌트가 렌더링되도록 설정한 것이다. 
    - v6 에서는 exact 가 사라지고 대신 와일트카드(`*`)을 사용하여 라우트를 설정한다. 예를들어 사용자가 존재하지 않는 경로로 접속했을 대 기본적으로 렌더링 되는 컴포넌트를 설정하는데 유리하게 사용할 수 있다. "페이지를 찾을 수 없음"과 같은 커스텀한 에러 페이지를 제공할 수 있는 것이다. 
    - `<Route path="*" component={NonPage} />`
6. Optional URL 파라미터가 사라짐 => Route 를 2번 선언할 것 : 이전 라우트에서는 ? 을 사용하여 서로 다른 경로를 보여줄 수 있었습니다. 
7. 서브라우터 : Outlet 설정 : `서브라우터`란 라우터 안에 또 다른 라우터를 내장하는 개념이다. 하나의 경로에 여러 개의 중첩된 라우터를 가질 수 있게 해주는 것으로 계층적인 라우팅 구조를 구현하고자 할 때 사용된다. 
    - 계층적인 라우팅 구조 : 상위 경로와 하위 경로 간의 관계를 나타내며, 각각의 경로에 대한 라우팅 로직을 묘듈화 한다. 
        ```javascript 
        <Route path="/dashboard" element={<Dashboard />} >
            <Route path="list" element={<List />} />
            <Route path="detail/:id" element={<Detail />} />
            <Route path="*" element={<NotFound />} />
        </Route>

        // list 는 자체적으로 경로를 가지지 않고, 부모 경로에 중첩된 라우트 컴포넌트에 렌더링된다. 
        // `/dashboard/list` 의 경로를 가지게 되는 것이다. 
        // `/dashboard/detail/:id`동일하게 detail의 경로는 이와 같다. 
        ```
    - 부모 경로 `/dashboard` 아래, 두개의 서브 경로가 설정되는 것이다.
    - 이후 Dashboard 컴포넌트 내부에 `<Outlet />`을 추가해주면 된다. 위치는 부모 컴포넌트의 레이아웃 구조와 요구사항에 맞게 배채한다. 
    - 기능상으로 볼 때, 아래의 두 코드는 동일한 동작을 수행한다. 다만 React Router v6에서는 중첩된 라우트를 더 명확하게 표현하는 두번째 방식을 권장한다. 이는 계층적인 라우팅 구조를 더 명확하게 표현하기 때문이다. 

        ```javascript 
        <Route path="/dashboard" element={<Dashboard />} />
        <Route path="/dashboard/:id" element={<DetailPage />} />

        // 

        <Route path="/dashboard" element={<Dashboard />} >
            <Route path=":id" element={<DetailPage />} />
        </Route>
        ```
8. NavLink 에 activeStyeld, activeClassName 사라짐 : 현재 페이지가 `활성화` 되어 있을 때, 특별한 스타일을 적용해주었던 기능이었다.

</details>

## 리액트 라우터 v6 튜토리얼, 21년 12월 28일
리액트에서 라우트 시스템을 구축하는 방법은 크게 2가지이다. (1) 리액트 라우터 (2) Next.js 이다. 먼저 후자는 최근에 등장한 프레임워크로 서버 사이드 렌더링 등의 다양한 기능을 제공하며 폴더와 파일 경로를 기반으로 작동한다. 반면에 전자는 전통적으로 클라이언트 사이드 렌더링을 지원하는 라우팅을 구성하게 한다. 이와 같이 리액트에서의 라우팅 구성은 서드 파티 라이브러리를 통해서 구성되는데, 이 외애도 다른 라이브러리들도 존재한다. 

1. SPA와 라우터 설정
    SPA이전에는 사용자의 요청이 발생되고, 새로운 페이지를 보여주어야 할 때마다, 서버 측에서 완성된 새로운 HTML 문서를 내려주어야 했고, 그 결과 많은 트래픽을 야기했다. 반면에 리액트는 SPA가 구성되도록 하기 위해 JS를 활용하여, 필요한 부분만을 업데이트하는 방식을 채택했습니다. 다른 말로 풀어서 설명하면, HTML은 하나이지만, 그 이후에 변경된 데이터 부분을 화면에서 업데이트하며 뷰를 구성한다는 것이다. 

    사용자 입장에서는 이러한 서비스를 통해서 기술적으로 하나의 페이지이지만, 여러 페이지가 있는 것처럼 느낄 수 있도록 한다. 이는 라우팅 시스템이 사용자의 브라우저 주소창의 경로에 따라 알맞는 페이지를 보여주기 때문이다. 그러나 SPA에서는 History API를 사용하여 브라우저의 주소창의 값만 변경할 뿐, 기존 HTML를 유지하면서 라우팅 설정엘 따라 다른 내용을 보여주는 것 뿐이다. 
<br/><br/>    

2. 라이브러리 사용하기 (1) `<BrowserRouter>`

    가장 먼저할 설정은 라우트의 최상단에 `<BrowserRouter>`로 감싸주는 것이다. `<BrowserRouter>`는 V6에서 도입된 개념인데, History API를 사용하여 페이지를 새로 불러오지 않고도 주소를 변경하여 현재 주소의 경로에 관련된 정보를 리액트 컴포넌트에서 사용할 수 있도록 한다. 

    ```javascript 
     <BrowserRouter>
        <App />
    </BrowserRouter>
    ```
<br/>

3. 라이브러리 사용하기 (2) `<Routes>`와 `<Route>`

    먼저 `<Route>`는 개별 라우트에 대한 설정이 이뤄지는 태그이다. path에는 경로값이, element에는 적용될 컴포넌트가 입력된다. 그리고 `<Route>`는 반드시 `<Routes>`에 의해서 감싸져 있어야 한다. 

    ```javascript 
     <BrowserRouter>
        <Routes>
            <Route path="/" element={<Home />} />
            <Route path="/about" element={<About />} />
        </Routes>
    </BrowserRouter>
    ```
<br/>

3. 라이브러리 사용하기 (3) 다른 경로로 이동하기 `<Link>`와 `useNavigate()`

    - `<Link>`를 살펴보자. HTML에서 사용되던 `<a>`태그와 같다고 여겨도 좋다. 여기서 이동에 대한 설정은 `to="경로"` 속성을 통해서 가능하다. Link 역시 페이지를 세로 불러오는 것이 아니라, HistoryAPI를 통해 브라우저 주소의 경로만 바꾸는 기능이 내장되어 있다. 
<br/><br/>

4. 라이브러리 사용하기 (4) 유동적인 주소값 설정히기 : `URL파라미터`와 `쿼리스트링`

    - UR파라미터 : /profile/:id
        ```javascript
        <Route path="/profiles/:id" element={<Profile />} />
        // 이동된 라우팅 페이지에서 UR파라미터는 `const params = useParams()`를 통해서 조회하는 것이 가능하다.
        // 이때 `params`는 객체 형태로 조회할 수 있다. 
        ```
    - 쿼리스트링 : /detailpage/section?key1=value1&key1=value1

        ```javascript 
        const About = () => {
            const location = useLocation();

            return (
                <div>
                    <p>쿼리스트링: {location.search}</p>
                </div>
            );
            };

            export default About;
        ```
        - 쿼리스트링은 `useLocation()`를 통해서 객체 정보를 반환받아 조회할 수 있다. 해당 객체에는 다음과 같은 값들이 들어있다. 
            - pathname : 쿼리스트링을 제외한 현재 주소의 경로를
            - search : 맨 앞의 ? 문자를 포함한 쿼리스트링의 값을 
                - `http://localhost:3000/about?detail=true&mode=1`의 URL이 있다면, `?detail=true&mode=1` 추출된다.
                - 복수(&)로 설정된 쿼리스트링에 대한 추출을 위해서 V6에서는 `useSearchParams()` 도입되었다. 

                    ```javascript 
                    // 위와 같은 URL이 존재한다면, 아래와 같이 각각의 key에 대한 내용을 추출할 수 있다. 
                    const [searchParams, setSearchParams] = useSearchParams();
                    const detail = searchParams.get('detail');
                    const mode = searchParams.get('mode');

                    const onIncreaseMode = () => {
                        const nextMode = mode === null ? 1 : parseInt(mode) + 1;
                        setSearchParams({ mode: nextMode, detail });
                    }; // .setSearchParams()을 통해서 특정 쿼리파라미터를 업데이트 할 수도 있다.  
                    ```
            - hash : 주소의 # 문자열 뒤의 값을 
            - state : 페이지로 이동할때 임의로 넣을 수 있는 상태 값
            - key : location 객체의 고유 값
<br/><br/>

5. 라이브러리 사용하기 (5) 중첩된 라우트와 Outlet

    해당부분의 설명은 조금 어렵기 때문에, 벨로퍼터의 벨로그에 대한 직접인용을 많이 하고자 한다. 

    ```jsx
    const Articles = () => { } // Article의 목차를 담당하는 컴포넌트
    const Article = () => {} // Article의 개별 페이지 

    // 각 컴포넌트에 대한 라우팅 처리 
    <Route path="/articles" element={<Articles />} />
    <Route path="/articles/:id" element={<Article />} />
    ```

    이후 `articles에 대한 접근`이 Home에서 `<Link>`를 통해서 접근하도록 제한되었다고 하자. [하단의 이미지](https://velog.io/@velopert/react-router-v6-tutorial)에서 중요하게 볼 부분은 URL 부분이다. /articles/1은 /articles를 통해서 접근한다. 
    <img src="https://velog.velcdn.com/images%2Fvelopert%2Fpost%2F63b759dc-e78d-4255-bf2b-9c19621bcae7%2F9.png" width="100%">

    그러나 고민은 이것이다. 게시글 목록 페이지에서 게시글을 열었을 때, 게시글 하단에 목록을 보여주고 싶은 것이다. 방법이 없지는 않다. `<Articles>`를 통해서 연결해주면 될 것이다. 그러나 이를 더 나은 방식으로 개선할 수 있는 접근법이 `중첩된 라우트 설정`이다. 이를 위해 라우트의 설정을 아래와 같이 변경할 수 있다. 

     ```jsx
    const Articles = () => { } // Article의 목차를 담당하는 컴포넌트
    const Article = () => {} // Article의 개별 페이지 

    // 각 컴포넌트에 대한 라우팅 처리 
    <Route path="/articles" element={<Articles />}>
        <Route path=":id" element={<Article />} />
    </Route>
    ```

    위에서 간략하게 다루었지만, `:id`의 경로는 상위 경로를 참조하여 `articles/:id`가 된다. 이후 이를 적용하기 위해서는 `<Outlet />`를 선언함으로 적용시킬 수 있었다.

    ```jsx
    import { Link, Outlet } from 'react-router-dom';

    const Articles = () => {
    return (
        <div>
        <Outlet />  
        {/* 라우트에서 처리된 children을 
            (<Route path=":id" element={<Article />} />) 이렇게 꺼내서 기록할 수 있는 것이다. */}
        <ul>
            <li>
            <Link to="/articles/1">게시글 1</Link>
            </li>
            <li>
            <Link to="/articles/2">게시글 2</Link>
            </li>
            <li>
            <Link to="/articles/3">게시글 3</Link>
            </li>
        </ul>
        </div>
    );
    };

    export default Articles;
    ```
    <img src="https://velog.velcdn.com/images%2Fvelopert%2Fpost%2F89eb1827-9032-4064-97ec-8a99c655fd10%2F13-10.png">
    <br/> 그런데 질문이 있다. 다름아니라 Home에서 Articles로 접근할 때이다. 초기에 설정되는 중첩라우트의 `:id`가 1로 설정이 자동으로 되는지의 여부이다.

    이 부분에 대한 GPT의 답변은 아래와 같다. 
    - 최초 : `/articles` 이동하면, `<Route path=":id".../>` 해당 경로가 없기 때문에, 보이지지 않게 된다. 
    - 그러나 게시글 목록을 통해서 해당 경로로 이동하면, 경로가 설정되며, `"/articles/1"`과 같은 경로로 이동하게 되는 것이다. 
    - 이는 useNavigate()를 통해 접근해도 동일한 결과를 얻을 수 있다. 
    <br/><br/>

    ```jsx
    import { useNavigate } from 'react-router-dom';

    const Articles = () => {
    const navigate = useNavigate();

    const handleNavigate = (path) => {
        navigate(path);
    };

    return (
        <div>
        <Outlet />
        <ul>
            <li>
            <button onClick={() => handleNavigate('/articles/1')}>게시글 1</button>
            </li>
            <li>
            <button onClick={() => handleNavigate('/articles/2')}>게시글 2</button>
            </li>
            <li>
            <button onClick={() => handleNavigate('/articles/3')}>게시글 3</button>
            </li>
        </ul>
        </div>
    );
    };

    export default Articles;
    ```

6. 라이브러리 사용하기 (5) 중첩된 라우트와 Outlet 의 응용

