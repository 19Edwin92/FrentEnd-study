## 이노캠모터스 회고노트

### 첫번째 이야기 
7월 21일 첫 만남으로 시작하여, 프로젝트를 진행한지 4일이 지났다. 6주라는 짧은 시간이지만, 틈틈히 회고를 남기지 않으면 공부한 기억들이 사장될 위험이 있기에, 이렇게 저금씩 공부했고, 고민했던 흔적들을 남기고자 한다. 

<details>
<summary>타입스크립트와 라이브러리, 맛보기</summary>
<br/>
가장 먼저 이야기할 부분은 `타입스크립트`에 대한 부분이었다. 이론으로 타입을 선언하는 부분에 대해서 공부했지만, 실전은 달랐다. 모든 것에 타입을 지정해주어야 했기 때문이다. 라이브러리에도 타입이 존재했으며, 해당 타입을 설정해주지 않으면 컴파일 단계에서 에러가 발생되어 아무것도 할 수 없는 상황이 되었다. 4일 동안의 짧은 기간이었지만, 그 동안의 짧은 이야기라도 기록으로 남겨, 훗날의 이를 회상하는데 도움을 주고자 한다. 

1. Axios 라이브러리의 타입적용

    리액트 JS에서는 고민없이 사용했던 라이브러리에도 타입설정이 필요했다. `인스턴스`를 생성하는 부분에도 타입설정이 필요했고, `인터셉터`를 적용하는 부분에서도 `config`와 `response`에 따라서 타입을 지정해 줘야 했다. 또한 번외의 이야기지만, `config`와 `response`를 인터셉터해서 어떤 처리를 하면, 반드시 두 요소를 return 해주어야 결과값을 전달하고 전달받는 다는 것 또한 유념해야할 이이었다. 

    ```tsx
    import axios, * as axiosType from 'axios';

    // axios 인스턴스 생성
    export const instance: axiosType.AxiosInstance = axios.create({
    baseURL: process.env.REACT_APP_SERVER_KEY,
    });

    interface MyAxiosRequestConfig extends axiosType.AxiosRequestConfig {
    headers: axiosType.AxiosRequestHeaders;
    }

    // 요청 인터셉터 설정
    instance.interceptors.request.use(
    (config: MyAxiosRequestConfig) => {
        ...
        return config;
    },
    (error) => {
        return Promise.reject(error);
    },
    );

    // 응답 인터셉터 설정
    instance.interceptors.response.use(
    (response: axiosType.AxiosResponse) => {
        ...
        return response;
    },
    (error) => {
        return Promise.reject(error);
    },
    );
    ```

2. RTK-query 라이브러리의 타입적용

    이번 4일의 작업에서 타입설정과 관련하여 가장 어려웠던 부분은 `RTK-query` 부분의 타입을 설정하는 일이었다. 특별히 `catch(error)` 부분의 타입을 지정해 주는 부분이 특별히 기억에 남는다. 반나절 정도를 찾아보고 내용을 적용시켰던 것 같다. 공식문서를 열심히 살펴보았지만, 익숙하지 않아서 어려움이 있었다. 그러나 이 과정에서 이미 라이브러리를 제공해주는 곳에서 만들어진 `index.d.ts`를 잘 살펴보는 것만으로 문제를 쉽게 접근할 수 있다는 것을 배우게 되었다. 

    ```tsx
    export const inocamRTK = createApi({
        baseQuery: axiosBaseQuery(),
        tagTypes: ['POSTS', 'POSTDETAIL', 'POSTCOMMENT'],
        endpoints(build) {}
    })
    ```

    (1) RTK-query에서 설정할 타입은 `axiosBaseQuery`부분으로 아래와 같다. 

    (2) `BaseQueryFn`를 설정함에 있어서, 개발자가 지정하고 싶은 내용을 추가로 기록할 수 있는데, 매번 포함되지 않는 요소에는 옵셔널체이닝(?)을 설정해 주었고, method와 data는 기본적으로 제공되어 있는 타입선언을 활용하면 된다. 

    ```tsx
    const axiosBaseQuery = (): BaseQueryFn<{
        url: string;
        method: AxiosRequestConfig['method']
        data?: AxiosRequestConfig['data'];
        types?: string;
    }> => async ({ url, method, data, types }) => {}
    ```

    (3) `catch (axiosError)`에 있어서의 에러타입설정 부분이 특히 어려웠다. 

    ```tsx
    catch (axiosError) {
        const err = axiosError as Type.CustomAxiosError<Type.ErrorType['data']>; // 타입단언
        return {
          error: err.response?.data.msg
        };
    }

    // responseType.d.ts
    export interface ErrorType {
        data: {
            error: boolean,
            status:number,
            msg: string
        }
    }
    export interface CustomAxiosError<T> extends AxiosError {
        response?: AxiosResponse<T>
    }
    ```

    타입가드도 생각해봤지만, 결국은 `타입단언`을 통해서 적용했다. 기존에 있었던 `AxiosError`를 상속받아서, `AxiosResponse`를 더하고, 여기에 `제네릭`을 설정했다. 그리고 이를 활용하는 부분에서 `ErrorType`를 넣어서 작업했다. 
</details>



<details>
<summary>타입스크립트와 타입선언</summary>
<br/>

타입선언은 `type`과 `interface` 두 가지 방법이 있고, 두 가지 방법은 각각의 목적과 사용 방법의 차이가 있다. 

1. `type` 알리아스(타입별칭)

    `type`은 기존 타임에 별칭을 붙여서 재사용하기 쉬운 커스텀 타입을 만들 때 유용한다. 타입의 확장은 아래와 같이 가능하다. 

    ```tsx
    type Person = {
        name: string;
        age: number;
    };

    type MyIntersection = Person & { email: string };
    ```

2. `interface` 객체의 구조를 정의한다. 

    주로 객체 간의 상호 작용을 명시적으로 지정하거나, 클래스가 구현해야 하는 메서드와 속성을 정의하는데 사용한다. 결국에는 성향차이라고 하는데, 일반적으로 별칭은 간단하고 범용적인 타입 선언에 적합하며, 인터페이스는 객체 간의 상호 작용과 클래스 구현에 더 적합한 것으로 구분하여 사용한다. 아래는 이번 프로젝트에서 사용한 `interface` 정의 목록이다. 범용적으로 사용하기 위해 타입을 구분했고, 각각의 상황에 따라서 사용할 수 있도록, export 해주었다. 

    ```tsx
    export interface CommentsData {
        comment_id: number;
        nickname: string;
        comment: string;
        created_at: string;
        modified_at: string;
    }

    export interface PostPosts {
        title:string;
        content:string;
        post_id?: number;
    }

    export interface PostsData extends PostPosts {
        is_like: boolean;
        like_count: number;
        comment_count?: number;
    }

    export interface PostsDetailData extends PostsData {
        image_urls: string[];
        comment: CommentsData[];
    }   
    ```

3. 컴포넌트의 props에 대한 타입지정

    ```tsx
     return (<EditCommunityDetail post_id={post_id} title={title} content={content} />)

     export const EditCommunityDetail: React.FC<Type.PostPosts> = ({ post_id, title, content }) => {

        return <div>로그인 ...</div>
     }
    ```
</details>


<details>
<summary>상태관리와 RTK-query, MSW</summary>
<br/>

상태관리는 언제나 어려운 주제이다. Redux, ContextAPI, 그리고 Recoil 등이 큰 축인 것 같다. 그리고 네트워크 통신과 관련해서는 RTK-createAysnsThunk, React-query, RTK-query 등으로 접근이 가능할 것이다. 

먼저, RTK-createAysnsThunk는 리덕스를 기반으로 확장되었다는 점에서 장점이 있다. 하지만, isLoading, isError 등의 상황을 모두 직접 기록해야 한다는 점과, 저장 위치가 메인 메모리에 저장된다는 점에서 다소 불편함이 있다. 

React-query는 네트워크 전용 상태관리를 표망하며, 비동기 통신 전용의 상태관리 라이브러리이다. 데이터를 캐시에 저장하여 효율적으로 데이터를 캐싱하고 패싱한다. 그러나 로직이 분산되어 있다는 한계는 있다. 

이번 프로젝트에서 채택한 RTK-query는 리덕스가 가진 중앙집중화의 장점을 가지고 API를 구현한다. 또한, 데이터를 React-query 처럼 캐시에 저장하여 효율적으로 데이터를 관리한다. 

이번 프로젝트에서는 axios + RTK-query + MSW를 통한 테스트 서버를 구현하여 빠르게 개발을 진행하도록 시도하였다. 

```tsx
export const inocamRTK = createApi({
  baseQuery: axiosBaseQuery(),
  tagTypes: ['POSTS', 'POSTDETAIL', 'POSTCOMMENT'],
  endpoints(build) {
    return {
      // loginRTK
      postLogin: build.mutation({
        query: (data) => ({
          url: '/api/auth/login',
          method: 'post',
          data,
          types: 'login',
        }),
      }),
      // Signup
      postSignup: build.mutation({
        query: (data) => ({
          url: '/api/auth/signup',
          method: 'post',
          data,
          types: 'signup',
        }),
      }),
      // getEmailCheck
      getEmailCheck: build.query({
        query: (email) => ({
          url: `/api/auth/email?email=${email}`,
          method: 'get',
          types: 'getCheck',
        }),
      }),
      // getNickNameCheck
      getNickCheck: build.query({
        query: (nickname) => ({
          url: `/api/auth/nickname?nickname=${nickname}`,
          method: 'get',
          types: 'getCheck',
        }),
      }),

      // getPosts - 차량출고 커뮤니티
      getPosts: build.query({
        query: () => ({
          url: `/api/posts`,
          method: 'get',
          types: 'getData',
        }),
        providesTags: ['POSTS']
      }),

      // postPosts - 차량출고 커뮤니티
      postPosts: build.mutation({
        query: (data) => ({
          url: `/api/posts`,
          method: 'post',
          data,
          types: 'multipart',
        }),
        invalidatesTags: ['POSTS']
      }),

      // DeletePosts - 차량출고 커뮤니티 게시글 삭제
      DeletePosts: build.mutation({
        query: (postId) => ({
          url: `/api/posts/${postId}`,
          method: 'delete',
        }),
        invalidatesTags: ['POSTS']
      }),

      // EditPosts - 차량출고 커뮤니티 게시글 수정
      patchPosts: build.mutation({
        query: ({postId, formData}) => ({
        url: `/api/posts/${postId}`,
        method: 'patch',
        data:formData,
        types:'multipart'
      }),
      invalidatesTags: ['POSTS', "POSTDETAIL"]
      }),


      // getPostsDetail - 차량출고 커뮤니티 게시글
      getPostsDetail: build.query({
        query: (postId) => ({
          url: `/api/posts/${postId}`,
          method: 'get',
          types: 'getData',
        }),
        providesTags: ['POSTDETAIL']
      }),

      // postComment - 차량출고 커뮤니티 댓글작성
      postComment: build.mutation({
        query: ({postId, data}) => ({
          url: `/api/posts/${postId}/comments`,
          method: 'post',
          data
        }),
        invalidatesTags: ['POSTDETAIL']
      }),


    };
  },
});

export const {
  // Auth
  usePostLoginMutation,
  usePostSignupMutation,
  useGetEmailCheckQuery,
  useGetNickCheckQuery,

  // Posts 차량출고 커뮤니티 관련
  useGetPostsQuery,
  usePostPostsMutation,
  useDeletePostsMutation,
  usePatchPostsMutation,
  useGetPostsDetailQuery,
  usePostCommentMutation,
} = inocamRTK;
```

중앙집중화 되어 있다는 점에서 `하나의 API`를 생성하는데 단 몇 분밖에 걸리지 않고, 쉽고 간편하게 useOOOQuery, useOOOMutation을 통해 호출하여 사용할 수 있다. 나아가 get 요청의 경우 조건부로 할 수 있을까 고민을 하게 되었다. 이전 프로젝트에서 React-query 를 했을 때, 사용했던 기억이 있는데 RTK-query도 간편하게 사용할 수 있었다. 

```tsx
 const { 
    isSuccess: checkEmailSuccess, 
    data: checkEmailData, 
    isError: checkEmailError, 
    error: emailError } = useGetEmailCheckQuery(signInfo.email, {skip: checkEmail})
```

`skip`에 들어가는 상태에 따라서 get요청을 제어할 수 있다. `true`를 하면 get요청이 무시된다. 이를 `false`로 변경될 때 요청이 시작된다. 이를 통해서 이메일체크와 닉네임체크 부분을 원하는 호출시점에 제어함으로 개발목적과 의도에 따라 동작하게 하였다. 

```tsx
  const onChangeInput = (e: ChangeEvent<HTMLInputElement>): void => {
    const { name, value } = e.target
    setSignInfo({ ...signInfo, [name]: value })
    setCheckEmail(true)
    setCheckNickName(true)
  }  
```

나아가 새로운 입력에 대한 이벤트가 발생되었을 때에는 이를 다시 true 로 번경하여 호출되지 않도록 제한하였다. 

### 이번에는 MSW이다. 

MSw는 정말 막강하다. API 배포와 디자인 가이드가 나오지 않는 시점에서 빠르게 코드를 테스르 하여, 서버통신을 가정한 상태로 개발을 진행할 수 있었고 그 결과는 대단했다. 다음은 이제 스타일드 컴포넌트를 모듈화하면 될 것 같다. 이후는 이제 생성한 모듈을 실제로 그리는 일만 남았다. 

```tsx
import { rest } from 'msw';
import * as TestDB from './testData';
import * as Type from '../types';


export const handlers = [
  // Login
  rest.post<Type.User>(`${process.env.REACT_APP_SERVER_KEY}/api/auth/login`,
    async (req, res, ctx) => {
      const request = req.body;
      const find = TestDB.logindata.find(user => user.email === request.email)

      if (find && request.password === find.password) {
        return res(
          ctx.status(200),
          ctx.json({
            success: true,
            status: 200,
            msg: '로그인성공',
          }),
          ctx.set(
            'authorization',
            'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5',
          ),
        );
        // 배열에서 존재하지 않으면...   
      } else if (find && request.password !== find.password) {
        return res(
          ctx.status(401), // 인증되지 않음
          ctx.json({
            error: true,
            status: 401,
            msg: '비밀번호가 틀렸습니다.',
          }),
        );
        // 배열은 있는데 비밀번호가 틀린 경우
      } else {
        return res(
          ctx.status(401), // 인증되지 않음(리소스에 없음) 
          ctx.json({
            error: true,
            status: 401,
            msg: '존재하지 않는 이메일 입니다.',
          }),
        );
      }
    },
  ),

  // Signup
  rest.post<Type.UserInfo>(`${process.env.REACT_APP_SERVER_KEY}/api/auth/signup`,
    async (req, res, ctx) => {
      const request = req.body;
      TestDB.logindata.push(request)
      return res(
        ctx.status(200),
        ctx.json({
          success: true,
          status: 200,
          msg: '회원가입성공',
        }),
      );
    }
  ),

  // Signup-emailCheck
  rest.get<Type.UserInfo>(`${process.env.REACT_APP_SERVER_KEY}/api/auth/email`,
    async (req, res, ctx) => {
      const checkEmail = req.url.searchParams.get('email')
      const find = TestDB.logindata.find(user => user.email === checkEmail) || null
      if (!find) {
        return res(
          ctx.status(200),
          ctx.json({
            success: true,
            status: 200,
            msg: '사용 가능한 이메일 입니다.'
          }),
        );
      } else {
        return res(
          ctx.status(409), // 이미 리소스 상에 존재하면
          ctx.json({
            error: true,
            status: 409,
            msg: '이미 존재하는 이메일 입니다.',
          }),
        );
      }
    }
  ),

  // Signup-NickNameCheck
  rest.get<Type.UserInfo>(`${process.env.REACT_APP_SERVER_KEY}/api/auth/nickname`,
    async (req, res, ctx) => {
      const checkNickName = req.url.searchParams.get('nickname')
      const find = TestDB.logindata.find(user => user.nickname === checkNickName) || null
      if (!find) {
        return res(
          ctx.status(200),
          ctx.json({
            success: true,
            status: 200,
            msg: '사용 가능한 닉네임 입니다.'
          }),
        );
      } else {
        return res(
          ctx.status(409), // 이미 리소스 상에 존재하면
          ctx.json({
            error: true,
            status: 409,
            msg: '이미 존재하는 닉네임 입니다.',
          }),
        );
      }
    }
  ),

  // getPosts - 차량출고 커뮤니티 
  rest.get(`${process.env.REACT_APP_SERVER_KEY}/api/posts`,
    async (_, res, ctx) => {
      return res(
        ctx.status(200),
        ctx.json({
          success: true,
          status: 200,
          msg: '게시글이 조회되었습니다.',
          data: TestDB.postdata
        }),
      );
    }
  ),

  // getPosts - 차량출고 커뮤니티 게시글 조회 
  rest.get(`${process.env.REACT_APP_SERVER_KEY}/api/posts/`, // ${postId}
    async (_, res, ctx) => {
      return res(
        ctx.status(200),
        ctx.json({
          success: true,
          status: 200,
          msg: '게시글이 조회되었습니다.',
          data: TestDB.postdata
        }),
      );
    }
  ),

  // getPostDeatil - 차량출고 커뮤니티 게시글 조회 
  rest.get(`${process.env.REACT_APP_SERVER_KEY}/api/posts/:id`,
    async (req, res, ctx) => {
      const find = TestDB.postDetailData.find(post => post.post_id === +req.params.id)
      return res(
        ctx.status(200),
        ctx.json({
          success: true,
          status: 200,
          msg: '게시글이 조회되었습니다.',
          data: [find]
        }),
      );
    }
  ),

  // postPosts - 차량출고 커뮤니티 
  rest.post(`${process.env.REACT_APP_SERVER_KEY}/api/posts`,
    async (_, res, ctx) => {
      return res(
        ctx.status(200),
        ctx.json({
          success: true,
          status: 200,
          msg: '게시글이 등록이 등록되었습니다.'
        }),
      );
    }
  ),

  // deletePosts - 차량출고 커뮤니티 게시글 삭제
  rest.delete(`${process.env.REACT_APP_SERVER_KEY}/api/posts/:id`,
    async (req, res, ctx) => {
      const findIndex = TestDB.postdata.findIndex((post: Type.PostsData) => post.post_id === +req.params.id)
      TestDB.postdata.splice(findIndex, 1)

      return res(
        ctx.status(200),
        ctx.json({
          success: true,
          status: 200,
          msg: '게시글이 삭제되었습니다.'
        }),
      );
    }
  ),

// patchPosts - 차량출고 커뮤니티 게시글 수정
rest.patch(`${process.env.REACT_APP_SERVER_KEY}/api/posts/:id`,
async (req, res, ctx) => {
  console.log("patchPosts", req);
  return res(
    ctx.status(200),
    ctx.json({
      success: true,
      status: 200,
      msg: '게시글이 수정되었습니다.'
    }),
  );
}
),

// postPostsComment - 차량출고 커뮤니티 게시글 댓글작성
rest.post(`${process.env.REACT_APP_SERVER_KEY}/api/posts/:id/comments`,
async (req, res, ctx) => {
  console.log("patchPosts", req.body);
  return res(
    ctx.status(200),
    ctx.json({
      success: true,
      status: 200,
      msg: '댓글이 입력 되었습니다.'
    }),
  );
}
),

// deletePostsComment - 차량출고 커뮤니티 게시글 댓글작성
rest.delete(`${process.env.REACT_APP_SERVER_KEY}/api/posts/:postid/comments/:commentid`,
async (req, res, ctx) => {
  console.log("deletePostsComment", req.params.id);
  return res(
    ctx.status(200),
    ctx.json({
      success: true,
      status: 200,
      msg: '댓글이 삭제 되었습니다.'
    }),
  );
}
),

// postPostsComment - 차량출고 커뮤니티 게시글 댓글작성
rest.patch(`${process.env.REACT_APP_SERVER_KEY}/api/posts/:postid/comments/:commentid`,
async (req, res, ctx) => {
  console.log("patchPosts", req.params.id, req.body);
  return res(
    ctx.status(200),
    ctx.json({
      success: true,
      status: 200,
      msg: '댓글이 수정 되었습니다.'
    }),
  );
}
),
];
```
</details>